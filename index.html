<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚µã‚¤ãƒãƒ¼ç ”ç©¶æ‰€ è„±å‡ºã‚²ãƒ¼ãƒ </title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    @keyframes marquee {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-200%); }
    }
    .animate-marquee {
      animation: marquee 30s linear infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ãƒãƒ¼ãƒ ã‚µã‚¤ã‚ºåˆ¥è¨­å®šï¼ˆe-ã‚¹ãƒãƒ¼ãƒ„ã‚³ãƒ¼ã‚¹é«˜æ ¡ç”Ÿå‘ã‘èª¿æ•´ï¼‰
    const TEAM_SETTINGS = {
      2: { timeLimit: 720, hintsRequired: 3, difficulty: 4 },  // 12åˆ†ã€3ãƒ’ãƒ³ãƒˆ
      3: { timeLimit: 780, hintsRequired: 4, difficulty: 4 },  // 13åˆ†ã€4ãƒ’ãƒ³ãƒˆ
      4: { timeLimit: 840, hintsRequired: 4, difficulty: 4 },  // 14åˆ†ã€4ãƒ’ãƒ³ãƒˆ
      5: { timeLimit: 900, hintsRequired: 5, difficulty: 4 },  // 15åˆ†ã€5ãƒ’ãƒ³ãƒˆ
    };

    const getTeamSettings = (size) => {
      return TEAM_SETTINGS[size] || TEAM_SETTINGS[5];
    };

const CyberEscapeGame = () => {
  const [screen, setScreen] = useState('entry');
  const [teamName, setTeamName] = useState('');
  const [teamNumber, setTeamNumber] = useState('');
  const [joinMode, setJoinMode] = useState('create');
  const [role, setRole] = useState(null);
  const [assignedRoles, setAssignedRoles] = useState([]);
  const [showMessage, setShowMessage] = useState(true);
  const [timeLeft, setTimeLeft] = useState(900);
  const [timerStarted, setTimerStarted] = useState(false);
  const [hintsFound, setHintsFound] = useState([]);
  const hintsFoundRef = useRef([]);  // æœ€æ–°ã®å€¤ã‚’å¸¸ã«å‚ç…§ã§ãã‚‹ã‚ˆã†ã«Ref
  const [puzzlesSolved, setPuzzlesSolved] = useState([]);
  const [nearbyObject, setNearbyObject] = useState(null);
  const [showHintModal, setShowHintModal] = useState(false);
  const [currentHint, setCurrentHint] = useState(null);
  const [showPuzzleModal, setShowPuzzleModal] = useState(false);
  const [showFinalInputModal, setShowFinalInputModal] = useState(false);  // æœ€çµ‚ãƒ‘ã‚ºãƒ«å…¥åŠ›ç”»é¢
  const [puzzleInput, setPuzzleInput] = useState(['', '', '', '', '']);
  const [puzzleError, setPuzzleError] = useState('');
  const [teamSize, setTeamSize] = useState(5);
  const [gameCompleted, setGameCompleted] = useState(false);
  const [completionTime, setCompletionTime] = useState(null);
  
  // ãƒœã‚¯ã‚»ãƒ«ãƒ‘ã‚ºãƒ«ç”¨ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [showVoxelPuzzle, setShowVoxelPuzzle] = useState(false);
  const [voxelPuzzleType, setVoxelPuzzleType] = useState(null);
  const [currentVoxelHintId, setCurrentVoxelHintId] = useState(null);
  const [voxelPuzzleTarget, setVoxelPuzzleTarget] = useState([]);
  const [voxelPuzzleProgress, setVoxelPuzzleProgress] = useState(0);
  
  // ç®¡ç†ç”»é¢ç”¨ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [adminPassword, setAdminPassword] = useState('');
  const [allTeams, setAllTeams] = useState([]);
  const [adminRefreshInterval, setAdminRefreshInterval] = useState(null);
  
  // ãƒ­ãƒ“ãƒ¼ç”»é¢ç”¨ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [lobbyData, setLobbyData] = useState(null);
  const [selectedRole, setSelectedRole] = useState(null);
  const [roleSelectTimer, setRoleSelectTimer] = useState(45);
  const [myPlayerId, setMyPlayerId] = useState(null);
  const [lobbyRefreshInterval, setLobbyRefreshInterval] = useState(null);
  
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const playerRef = useRef({ x: 0, z: 5, rotation: 0, rotationX: 0 });
  const keysRef = useRef({});
  const isMouseDownRef = useRef(false);
  const lastMouseRef = useRef({ x: 0, y: 0 });
  const animationIdRef = useRef(null);
  const hintObjectsRef = useRef([]);
  const consoleRef = useRef(null);

  // ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ãƒã‚¿ãƒ¼ç”¨
  const otherPlayersRef = useRef({});    // ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ { oderId: { current, target, roleIndex, roleName } }
  const avatarMeshesRef = useRef({});    // ã‚¢ãƒã‚¿ãƒ¼ãƒ¡ãƒƒã‚·ãƒ¥ç®¡ç† { oderId: THREE.Group }

  // ãƒœã‚¯ã‚»ãƒ«ãƒ‘ã‚ºãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  // åå°„ç¥çµŒã‚²ãƒ¼ãƒ ã‚’DOMç›´æ¥æ“ä½œã§å®Ÿè£…ï¼ˆReactã®å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‹ã‚‰å®Œå…¨ã«ç‹¬ç«‹ï¼‰
  const reflexGameContainerRef = useRef(null);
  
  const startReflexGame = (diff, puzzType, onComp, onCls) => {
    // æ—¢å­˜ã®ã‚²ãƒ¼ãƒ ãŒã‚ã‚Œã°å‰Šé™¤
    const existing = document.getElementById('reflex-game-container');
    if (existing) existing.remove();
    
    // ã‚³ãƒ³ãƒ†ãƒŠä½œæˆ
    const container = document.createElement('div');
    container.id = 'reflex-game-container';
    container.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:99999;display:flex;align-items:center;justify-content:center;';
    document.body.appendChild(container);
    
    // è¨­å®šï¼ˆeã‚¹ãƒãƒ¼ãƒ„ç”Ÿå¾’å‘ã‘ - é«˜é€Ÿç‰ˆï¼‰
    const settings = {
      1: { targetCount: 3, spawnInterval: 600, targetLife: 1200, required: 8 },
      2: { targetCount: 4, spawnInterval: 550, targetLife: 1100, required: 10 },
      3: { targetCount: 5, spawnInterval: 520, targetLife: 1050, required: 12 },
      4: { targetCount: 6, spawnInterval: 500, targetLife: 1000, required: 15 },
      5: { targetCount: 7, spawnInterval: 500, targetLife: 1000, required: 18 },
    };
    const config = settings[Math.min(diff, 5)] || settings[2];
    const stars = 'â˜…'.repeat(diff) + 'â˜†'.repeat(5-diff);
    const title = puzzType === 'final' ? 'ğŸ” æœ€çµ‚èªè¨¼ãƒãƒ£ãƒ¬ãƒ³ã‚¸' : 'âš¡ åå°„ç¥çµŒãƒ†ã‚¹ãƒˆ';
    
    // UIä½œæˆ
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'background:#1f2937;border:2px solid #00ffff;border-radius:8px;padding:24px;max-width:640px;width:100%;margin:16px;';
    
    const titleEl = document.createElement('h2');
    titleEl.style.cssText = 'color:#00ffff;font-size:24px;font-weight:bold;text-align:center;margin-bottom:16px;';
    titleEl.textContent = title;
    wrapper.appendChild(titleEl);
    
    const contentDiv = document.createElement('div');
    contentDiv.id = 'reflex-content';
    contentDiv.innerHTML = '<div style="text-align:center;padding:32px 0;">' +
      '<p style="color:#d1d5db;margin-bottom:16px;">å…‰ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ï¼</p>' +
      '<p style="color:#00ffff;margin-bottom:8px;">ç›®æ¨™: ' + config.required + 'å€‹ / åˆ¶é™æ™‚é–“: 20ç§’</p>' +
      '<p style="color:#6b7280;font-size:14px;margin-bottom:24px;">é›£æ˜“åº¦: ' + stars + '</p>' +
      '<button id="reflex-start" style="background:#0891b2;color:white;font-weight:bold;padding:12px 32px;border-radius:8px;font-size:20px;border:none;cursor:pointer;">ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>' +
      '</div>';
    wrapper.appendChild(contentDiv);
    
    const closeBtn = document.createElement('button');
    closeBtn.style.cssText = 'width:100%;margin-top:16px;background:#374151;color:white;font-weight:bold;padding:8px;border-radius:4px;border:none;cursor:pointer;';
    closeBtn.textContent = 'é–‰ã˜ã‚‹';
    closeBtn.onclick = function() { container.remove(); onCls(); };
    wrapper.appendChild(closeBtn);
    
    container.appendChild(wrapper);
    
    // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
    document.getElementById('reflex-start').onclick = function() {
      var content = document.getElementById('reflex-content');
      var canvas = document.createElement('canvas');
      canvas.id = 'reflex-canvas';
      canvas.width = 560;
      canvas.height = 360;
      canvas.style.cssText = 'width:100%;border-radius:4px;border:1px solid #374151;cursor:crosshair;';
      content.innerHTML = '';
      content.appendChild(canvas);
      
      var ctx = canvas.getContext('2d');
      var W = canvas.width, H = canvas.height;
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
      var score = 0, timeLeft = 20, targets = [], animId = null, timerId = null;
      var cols = 4, rows = 3, cellW = W/cols, cellH = H/rows;
      var positions = [];
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
          positions.push({ x: c*cellW + cellW/2, y: r*cellH + cellH/2, occupied: false });
        }
      }
      
      var lastSpawn = 0;
      
      function spawnTarget(now) {
        var free = positions.filter(function(p) { return !p.occupied; });
        if (free.length === 0 || targets.length >= config.targetCount) return;
        var pos = free[Math.floor(Math.random() * free.length)];
        pos.occupied = true;
        targets.push({
          x: pos.x, y: pos.y, radius: 40, spawnTime: now, life: config.targetLife,
          pos: pos, hit: false, hue: Math.random()*60+160
        });
      }
      
      function draw(now) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);
        
        ctx.strokeStyle = '#00ffff33';
        for (var i = 1; i < cols; i++) { ctx.beginPath(); ctx.moveTo(i*cellW, 0); ctx.lineTo(i*cellW, H); ctx.stroke(); }
        for (var i = 1; i < rows; i++) { ctx.beginPath(); ctx.moveTo(0, i*cellH); ctx.lineTo(W, i*cellH); ctx.stroke(); }
        
        targets.forEach(function(t) {
          var age = now - t.spawnTime;
          var life = Math.max(0, 1 - age / t.life);
          if (t.hit) {
            ctx.beginPath(); ctx.arc(t.x, t.y, t.radius*1.5*life, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,255,100,' + life + ')'; ctx.fill();
          } else {
            var g = ctx.createRadialGradient(t.x-10, t.y-10, 5, t.x, t.y, t.radius);
            g.addColorStop(0, '#fff');
            g.addColorStop(0.3, 'hsl(' + t.hue + ', 100%, 50%)');
            g.addColorStop(1, '#003');
            ctx.beginPath(); ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
            ctx.fillStyle = g; ctx.fill();
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = life > 0.3 ? '#0f0' : '#f00';
            ctx.fillRect(t.x-30, t.y+t.radius+5, 60*life, 5);
          }
        });
        
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'left'; ctx.fillText('SCORE: ' + score + ' / ' + config.required, 10, 30);
        ctx.textAlign = 'right'; ctx.fillStyle = timeLeft <= 5 ? '#f44' : '#fff';
        ctx.fillText('TIME: ' + timeLeft, W-10, 30);
      }
      
      function endGame(won) {
        cancelAnimationFrame(animId);
        clearInterval(timerId);
        if (won) {
          content.innerHTML = '<div style="text-align:center;padding:32px;"><div style="color:#4ade80;font-size:36px;font-weight:bold;">âœ“ ã‚¯ãƒªã‚¢ï¼</div></div>';
          setTimeout(function() { container.remove(); onComp(); }, 1000);
        } else {
          content.innerHTML = '<div style="text-align:center;padding:32px;">' +
            '<div style="color:#f87171;font-size:24px;font-weight:bold;margin-bottom:16px;">ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—...</div>' +
            '<p style="color:#9ca3af;margin-bottom:16px;">ã‚¹ã‚³ã‚¢: ' + score + ' / ' + config.required + '</p>' +
            '<button id="reflex-retry" style="background:#0891b2;color:white;font-weight:bold;padding:8px 24px;border-radius:4px;border:none;cursor:pointer;">ã‚‚ã†ä¸€åº¦</button>' +
            '</div>';
          document.getElementById('reflex-retry').onclick = function() { container.remove(); startReflexGame(diff, puzzType, onComp, onCls); };
        }
      }
      
      function loop(now) {
        if (now - lastSpawn > config.spawnInterval) { spawnTarget(now); lastSpawn = now; }
        targets = targets.filter(function(t) {
          var age = now - t.spawnTime;
          if (t.hit && age > 300) { t.pos.occupied = false; return false; }
          if (!t.hit && age > t.life) { t.pos.occupied = false; return false; }
          return true;
        });
        draw(now);
        animId = requestAnimationFrame(loop);
      }
      
      canvas.onclick = function(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.clientX - rect.left) * (W / rect.width);
        var y = (e.clientY - rect.top) * (H / rect.height);
        for (var i = targets.length - 1; i >= 0; i--) {
          var t = targets[i];
          if (t.hit) continue;
          if (Math.sqrt(Math.pow(x-t.x, 2) + Math.pow(y-t.y, 2)) < t.radius) {
            t.hit = true; t.spawnTime = performance.now(); score++;
            if (score >= config.required) endGame(true);
            break;
          }
        }
      };
      
      timerId = setInterval(function() {
        timeLeft--;
        if (timeLeft <= 0) endGame(score >= config.required);
      }, 1000);
      
      animId = requestAnimationFrame(loop);
    };
  };

  // é›£æ˜“åº¦ã«å¿œã˜ãŸãƒ‘ã‚ºãƒ«å½¢çŠ¶ã‚’ç”Ÿæˆï¼ˆå…¨ã¦1æ®µç›®ã®ã¿ï¼‰
  const generatePuzzleShape = (difficulty) => {
    const shapes = {
      // 2äººãƒãƒ¼ãƒ ç”¨ï¼ˆç°¡å˜ï¼‰- 2ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆæ¨ªä¸¦ã³ï¼‰
      1: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 }
      ],
      // 3äººãƒãƒ¼ãƒ ç”¨ - 3ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆLå­—ï¼‰
      2: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 }
      ],
      // 4äººãƒãƒ¼ãƒ ç”¨ - 4ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆTå­—ï¼‰
      3: [
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 2, y: 0, z: 1 },
        { x: 1, y: 0, z: 0 }
      ],
      // 5äººãƒãƒ¼ãƒ ç”¨ - 5ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆåå­—ï¼‰
      4: [
        { x: 1, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 2, y: 0, z: 1 },
        { x: 1, y: 0, z: 2 }
      ],
      // æœ€çµ‚ãƒ‘ã‚ºãƒ«ç”¨ - 7ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆå¤§ããªå½¢çŠ¶ï¼‰
      5: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 },
        { x: 2, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 0, y: 0, z: 2 },
        { x: 1, y: 0, z: 2 }
      ]
    };
    return shapes[Math.min(difficulty, 5)] || shapes[1];
  };

  // ãƒãƒ¼ãƒ äººæ•°ã‹ã‚‰é›£æ˜“åº¦ã‚’è¨ˆç®—ï¼ˆå…¨ãƒãƒ¼ãƒ é›£æ˜“åº¦4ã«çµ±ä¸€ï¼‰
  const getDifficultyFromTeamSize = (size) => {
    return getTeamSettings(size).difficulty;
  };

  // ç®¡ç†ç”»é¢: å…¨ãƒãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const fetchAllTeams = async () => {
    try {
      const teams = await supabase.getAllTeams();
      console.log('fetchAllTeams: å–å¾—çµæœ', teams);
      if (teams && teams.length > 0) {
        const formattedTeams = teams.map(function(t) {
          return Object.assign({}, t.data || {}, { name: t.name, number: t.code, code: t.code });
        });
        // ã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ é †ã€æœªã‚¯ãƒªã‚¢ã¯é€²æ—é †ã«ã‚½ãƒ¼ãƒˆ
        formattedTeams.sort(function(a, b) {
          if (a.completed && b.completed) {
            return (a.completionTime || 9999) - (b.completionTime || 9999);
          }
          if (a.completed) return -1;
          if (b.completed) return 1;
          return (b.hintsFound?.length || 0) - (a.hintsFound?.length || 0);
        });
        setAllTeams(formattedTeams);
      } else {
        setAllTeams([]);
      }
    } catch (error) {
      console.error('Error fetching teams:', error);
      setAllTeams([]);
    }
  };

  // ç®¡ç†ç”»é¢ã«å…¥ã‚‹
  const enterAdminScreen = () => {
    if (adminPassword === 'admin123') {
      setScreen('admin');
      fetchAllTeams();
      // 5ç§’ã”ã¨ã«æ›´æ–°
      const interval = setInterval(fetchAllTeams, 5000);
      setAdminRefreshInterval(interval);
    } else {
      alert('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™');
    }
  };

  // ç®¡ç†ç”»é¢ã‹ã‚‰é€€å‡º
  const exitAdminScreen = () => {
    if (adminRefreshInterval) {
      clearInterval(adminRefreshInterval);
      setAdminRefreshInterval(null);
    }
    setScreen('entry');
    setAdminPassword('');
  };

  // ãƒãƒ¼ãƒ ã®æ®‹ã‚Šæ™‚é–“ã‚’è¨ˆç®—ï¼ˆãƒãƒ¼ãƒ ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåˆ¶é™æ™‚é–“ï¼‰
  const getTeamTimeLeft = (team) => {
    const teamTimeLimit = getTeamSettings(team.maxMembers || 5).timeLimit;
    if (!team.startTime) return teamTimeLimit;
    if (team.completed) return teamTimeLimit - (team.completionTime || 0);
    const elapsed = Math.floor((Date.now() - team.startTime) / 1000);
    return Math.max(0, teamTimeLimit - elapsed);
  };

  // å…¨ãƒãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
  const resetAllTeams = async () => {
    if (!confirm('å…¨ã¦ã®ãƒãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')) return;
    try {
      const teams = await supabase.getAllTeams();
      console.log('resetAllTeams: å–å¾—ã—ãŸãƒãƒ¼ãƒ ', teams);
      if (teams && teams.length > 0) {
        for (var i = 0; i < teams.length; i++) {
          console.log('resetAllTeams: å‰Šé™¤ä¸­', teams[i].code);
          await supabase.deleteTeam(teams[i].code);
        }
      }
      setAllTeams([]);
      alert('å…¨ãƒãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
    } catch (error) {
      console.error('Error resetting teams:', error);
      alert('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  };

  // ãƒ­ãƒ“ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const fetchLobbyData = async () => {
    const team = await supabase.getTeam(teamNumber);
    if (team) {
      const data = team.data;
      data.name = team.name;
      data.number = team.number;
      setLobbyData(data);
      
      // å…¨å“¡æƒã£ãŸã‚‰ãƒ­ãƒ“ãƒ¼é–‹å§‹æ™‚åˆ»ã‚’ã‚»ãƒƒãƒˆ
      const maxMembers = data.maxMembers || teamSize;
      const allJoined = data.members && data.members.length >= maxMembers;
      
      if (allJoined && !data.lobbyStartTime) {
        data.lobbyStartTime = Date.now();
        await supabase.updateTeam(teamNumber, data);
      }
      
      // æ®‹ã‚Šæ™‚é–“ã‚’è¨ˆç®—ï¼ˆå…¨å“¡æƒã£ã¦ã‹ã‚‰ï¼‰
      if (data.lobbyStartTime) {
        const elapsed = Math.floor((Date.now() - data.lobbyStartTime) / 1000);
        const remaining = Math.max(0, 45 - elapsed);
        setRoleSelectTimer(remaining);
        
        // ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—ã§ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆå½¹å‰²æœªé¸æŠã§ã‚‚è‡ªå‹•å‰²ã‚Šå½“ã¦ï¼‰
        if (remaining <= 0 && !data.gameStarted) {
          autoAssignAndStart(data);
        }
      }
      
      // ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ãŸã‚‰è‡ªåˆ†ã‚‚ç§»è¡Œ
      if (data.gameStarted) {
        const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
        if (myEntry) {
          const availableRoles = getRolesForTeamSize(data.maxMembers || teamSize);
          // å½¹å‰²ãŒæœªå‰²ã‚Šå½“ã¦ã®å ´åˆã¯ç©ºã„ã¦ã„ã‚‹å½¹å‰²ã‚’å‰²ã‚Šå½“ã¦
          if (myEntry.roleIndex === undefined) {
            const takenRoles = data.members.filter(function(m) { return m.roleIndex !== undefined && m.oderId !== myPlayerId; }).map(function(m) { return m.roleIndex; });
            for (var i = 0; i < availableRoles.length; i++) {
              if (!takenRoles.includes(i)) {
                myEntry.roleIndex = i;
                break;
              }
            }
          }
          if (myEntry.roleIndex !== undefined) {
            setRole(availableRoles[myEntry.roleIndex]);
            setAssignedRoles([availableRoles[myEntry.roleIndex]]);
            setSelectedRole(myEntry.roleIndex);
            const currentTeamSize = data.maxMembers || teamSize;
            setTeamSize(currentTeamSize);
            setTimeLeft(getTeamSettings(currentTeamSize).timeLimit);
            // ãƒãƒ¼ãƒ ã®ãƒ’ãƒ³ãƒˆã‚’èª­ã¿è¾¼ã¿
            if (data.hintsFound) setHintsFound(data.hintsFound);
            setShowMessage(true);
            setTimerStarted(true);
            setScreen('game');
          }
        }
      }
    }
  };

  // å½¹å‰²ã‚’é¸æŠ
  const selectRole = async (roleIndex) => {
    if (!lobbyData || selectedRole !== null) return;
    
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const data = team.data;
    
    // æ—¢ã«èª°ã‹ãŒé¸ã‚“ã§ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    const alreadyTaken = data.members.some(function(m) { return m.roleIndex === roleIndex; });
    if (alreadyTaken) {
      alert('ã“ã®å½¹å‰²ã¯æ—¢ã«é¸ã°ã‚Œã¦ã„ã¾ã™');
      fetchLobbyData();
      return;
    }
    
    // è‡ªåˆ†ã®ã‚¨ãƒ³ãƒˆãƒªã‚’æ›´æ–°
    const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
    if (myEntry) {
      myEntry.roleIndex = roleIndex;
      const availableRoles = getRolesForTeamSize(data.maxMembers || teamSize);
      myEntry.roleName = availableRoles[roleIndex].name;
      await supabase.updateTeam(teamNumber, data);
      setSelectedRole(roleIndex);
      setLobbyData(data);
    }
  };

  // è‡ªå‹•å‰²ã‚Šå½“ã¦ã—ã¦ã‚²ãƒ¼ãƒ é–‹å§‹
  const autoAssignAndStart = async (oldData) => {
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const latestData = team.data;
    
    if (latestData.gameStarted) return;
    
    const maxMembers = latestData.maxMembers || teamSize;
    const availableRoles = getRolesForTeamSize(maxMembers);
    
    // æœªé¸æŠã®ãƒ¡ãƒ³ãƒãƒ¼ã«å½¹å‰²ã‚’è‡ªå‹•å‰²ã‚Šå½“ã¦
    const takenRoles = latestData.members.filter(function(m) { return m.roleIndex !== undefined; }).map(function(m) { return m.roleIndex; });
    const freeRoles = [];
    
    for (let i = 0; i < availableRoles.length; i++) {
      if (!takenRoles.includes(i)) {
        freeRoles.push(i);
      }
    }
    
    latestData.members.forEach(member => {
      if (member.roleIndex === undefined && freeRoles.length > 0) {
        member.roleIndex = freeRoles.shift();
        member.roleName = availableRoles[member.roleIndex].name;
        member.autoAssigned = true;
      }
    });
    
    latestData.gameStarted = true;
    latestData.startTime = Date.now();
    await supabase.updateTeam(teamNumber, latestData);
    
    // è‡ªåˆ†ã®å½¹å‰²ã‚’è¨­å®šã—ã¦ã‚²ãƒ¼ãƒ ç”»é¢ã¸
    const myEntry = latestData.members.find(function(m) { return m.oderId === myPlayerId; });
    if (myEntry && myEntry.roleIndex !== undefined) {
      const myRole = availableRoles[myEntry.roleIndex];
      setRole(myRole);
      setAssignedRoles([myRole]);
      setSelectedRole(myEntry.roleIndex);
    }
    
    setTeamSize(maxMembers);
    setTimeLeft(getTeamSettings(maxMembers).timeLimit);
    // ãƒãƒ¼ãƒ ã®ãƒ’ãƒ³ãƒˆã‚’èª­ã¿è¾¼ã¿
    if (latestData.hintsFound) setHintsFound(latestData.hintsFound);
    setTimerStarted(true);
    setScreen('game');
  };

  // ãƒ­ãƒ“ãƒ¼ã«å…¥ã‚‹
  const enterLobby = async () => {
    console.log('enterLobby: ãƒãƒ¼ãƒ ç•ªå·ã‚’æ¤œç´¢ä¸­...', teamNumber);
    const team = await supabase.getTeam(teamNumber);
    console.log('enterLobby: æ¤œç´¢çµæœ:', team);
    if (!team) {
      alert('ãƒãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆç•ªå·: ' + teamNumber + 'ï¼‰');
      return;
    }
    const data = team.data;
    
    // æ—¢ã«ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ãªã‚‰ç›´æ¥ã‚²ãƒ¼ãƒ ã¸ï¼ˆé€”ä¸­å‚åŠ ï¼‰
    if (data.gameStarted) {
      alert('ã‚²ãƒ¼ãƒ ã¯æ—¢ã«é–‹å§‹ã•ã‚Œã¦ã„ã¾ã™');
      return;
    }
    
    // äººæ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
    if (data.members && data.members.length >= data.maxMembers) {
      alert('ãƒãƒ¼ãƒ ã¯æº€å“¡ã§ã™');
      return;
    }
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’ç”Ÿæˆ
    const oderId = 'P' + Date.now();
    setMyPlayerId(oderId);
    
    // ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦è¿½åŠ 
    if (!data.members) data.members = [];
    data.members.push({
      oderId: oderId,
      joinTime: Date.now(),
      roleIndex: undefined,
      roleName: undefined
    });
    
    await supabase.updateTeam(teamNumber, data);
    setLobbyData(data);
    setRoleSelectTimer(45);
    setScreen('lobby');
  };

  // ãƒ†ã‚¹ãƒˆç”¨ï¼šãƒ€ãƒŸãƒ¼ãƒ¡ãƒ³ãƒãƒ¼è¿½åŠ 
  const forceFullTeam = async () => {
    const team = await supabase.getTeam(teamNumber);
    if (team) {
      const data = team.data;
      const maxMembers = data.maxMembers || teamSize;
      while (data.members.length < maxMembers) {
        data.members.push({
          oderId: 'DUMMY' + Date.now() + Math.random(),
          joinTime: Date.now(),
          roleIndex: undefined
        });
      }
      await supabase.updateTeam(teamNumber, data);
      setLobbyData(data);
      fetchLobbyData();
      alert('ãƒ†ã‚¹ãƒˆç”¨ã«ãƒ€ãƒŸãƒ¼ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¿½åŠ ã—ã¾ã—ãŸ');
    }
  };

  // ãƒ­ãƒ“ãƒ¼ã‹ã‚‰é€€å‡º
  const exitLobby = () => {
    if (lobbyRefreshInterval) {
      clearInterval(lobbyRefreshInterval);
      setLobbyRefreshInterval(null);
    }
    setScreen('entry');
    setSelectedRole(null);
    setLobbyData(null);
    setMyPlayerId(null);
  };

  // æº–å‚™å®Œäº†ï¼ˆå½¹å‰²ç¢ºå®šã—ã¦ã‚²ãƒ¼ãƒ é–‹å§‹å¾…ã¡ï¼‰
  const confirmRoleAndWait = async () => {
    if (selectedRole === null) {
      alert('å½¹å‰²ã‚’é¸ã‚“ã§ãã ã•ã„');
      return;
    }
    
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;
      
      const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
      if (myEntry) {
        myEntry.ready = true;
        await supabase.updateTeam(teamNumber, data);
      }
      
      // å…¨å“¡æº–å‚™å®Œäº†ã‹ãƒã‚§ãƒƒã‚¯
      const allReady = data.members.every(function(m) { return m.ready; });
      if (allReady && data.members.length >= 2) {
        await autoAssignAndStart(data);
      }
    } catch (error) {
      console.error('Confirm role error:', error);
    }
  };

  // ãƒ­ãƒ“ãƒ¼ã‚¿ã‚¤ãƒãƒ¼
  useEffect(() => {
    if (screen === 'lobby' && roleSelectTimer > 0) {
      const timer = setTimeout(() => {
        setRoleSelectTimer(prev => Math.max(0, prev - 1));
      }, 1000);
      return () => clearTimeout(timer);
    } else if (screen === 'lobby' && roleSelectTimer === 0 && lobbyData && !lobbyData.gameStarted) {
      autoAssignAndStart(lobbyData);
    }
  }, [screen, roleSelectTimer, lobbyData]);

  // ãƒ­ãƒ“ãƒ¼çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  useEffect(() => {
    return () => {
      if (lobbyRefreshInterval) {
        clearInterval(lobbyRefreshInterval);
      }
    };
  }, [lobbyRefreshInterval]);

  // å½¹å‰²å®šç¾©ï¼ˆ5ç¨®é¡ï¼‰- ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸3è¡Œ
  // å½¹å‰²å®šç¾©ï¼ˆäººæ•°ã«å¿œã˜ã¦ä½¿ç”¨ï¼‰
  const roleDefinitions = {
    leader: { id: 'leader', name: 'ãƒªãƒ¼ãƒ€ãƒ¼', icon: 'ğŸ‘‘', color: '#ffd700' },
    decoder: { id: 'decoder', name: 'è§£èª­å“¡', icon: 'ğŸ”“', color: '#ff6b6b' },
    investigator: { id: 'investigator', name: 'èª¿æŸ»å“¡', icon: 'ğŸ”', color: '#4ecdc4' },
    analyst: { id: 'analyst', name: 'åˆ†æå“¡', icon: 'ğŸ“Š', color: '#95e1d3' },
    communicator: { id: 'communicator', name: 'é€šä¿¡å“¡', icon: 'ğŸ“¡', color: '#dda0dd' },
  };

  // äººæ•°åˆ¥å½¹å‰²ãƒªã‚¹ãƒˆ
  const getRolesForTeamSize = (size) => {
    const r = roleDefinitions;
    switch(size) {
      case 2: return [r.leader, r.decoder];
      case 3: return [r.leader, r.decoder, r.investigator];
      case 4: return [r.leader, r.decoder, r.investigator, r.analyst];
      case 5: return [r.leader, r.decoder, r.investigator, r.analyst, r.communicator];
      default: return [r.leader, r.decoder];
    }
  };

  // äººæ•°åˆ¥ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  const getSecretMessage = (size, roleId) => {
    const messages = {
      2: {
        leader: ['ã€æŒ‡ä»¤ã€‘æœ€çµ‚å…¥åŠ›ã¯ã‚ãªãŸãŒè¡Œã†', 'å›³å½¢ã®ã€Œä½•ã‹ã€ãŒé †ç•ªã‚’æ±ºã‚ã‚‹ã‚‰ã—ã„', 'ç›¸æ£’ã¨å”åŠ›ã—ã¦æ³•å‰‡ã‚’è¦‹ã¤ã‘ã‚ˆ'],
        decoder: ['ã€å—ä¿¡ã€‘æ•°å­—ã®åˆ—ã‚’å‚å—ã—ãŸ', 'ã—ã‹ã—æ„å‘³ãŒã‚ã‹ã‚‰ãªã„', 'ç›¸æ£’ã¨ä¸€ç·’ã«è§£èª­ã›ã‚ˆ'],
      },
      3: {
        leader: ['ã€æŒ‡ä»¤ã€‘æœ€çµ‚å…¥åŠ›ã¯ã‚ãªãŸãŒè¡Œã†', 'ã€Œæ³•å‰‡ã€ã¨ã€Œå¯¾å¿œè¡¨ã€ãŒå¿…è¦ã‚‰ã—ã„', 'ä»²é–“ã‹ã‚‰æƒ…å ±ã‚’é›†ã‚ã‚ˆ'],
        decoder: ['ã€å—ä¿¡ã€‘é †ç•ªã«ã¯æ³•å‰‡ãŒã‚ã‚‹', 'ã€Œè§’ã€ã«é–¢ä¿‚ã™ã‚‹ã‚‰ã—ã„ãŒ...', 'è©³ç´°ã¯èª¿æŸ»ãŒå¿…è¦'],
        investigator: ['ã€å ±å‘Šã€‘è‰²ä»˜ãã®çŸ³æ¿ã‚’ç™ºè¦‹', 'é’ã€ç·‘ã€é»„ã€èµ¤ã€ç´«ã®5è‰²', 'ãã‚Œãã‚Œã«ã€Œå½¢ã€ãŒå¯¾å¿œã—ã¦ã„ã‚‹'],
      },
      4: {
        leader: ['ã€æŒ‡ä»¤ã€‘æœ€çµ‚å…¥åŠ›ã¯ã‚ãªãŸãŒè¡Œã†', 'è‡ªåˆ†ã¯ä½•ã‚‚æƒ…å ±ã‚’æŒã£ã¦ã„ãªã„', '3äººå…¨å“¡ã‹ã‚‰å ±å‘Šã‚’å—ã‘ã‚ˆ'],
        decoder: ['ã€å—ä¿¡ã€‘é †ç•ªã®æ³•å‰‡ã‚’ä¸€éƒ¨è§£èª­', 'ã€Œè§’ã®æ•°ã€ãŒé–¢ä¿‚ã—ã¦ã„ã‚‹', 'ã ãŒæ•°å­—ãŒã‚ã‹ã‚‰ãªã„'],
        investigator: ['ã€å ±å‘Šã€‘çŸ³æ¿ã®è‰²ã‚’ç™ºè¦‹', 'é’â†’ç·‘â†’é»„â†’?â†’?', 'æ®‹ã‚Šã®è‰²ã¨å½¢ã¯èª¿æŸ»ä¸­'],
        analyst: ['ã€è§£æã€‘æ•°å­—ã®æ–­ç‰‡ã‚’ç™ºè¦‹', '3, 4, ?, ?, 4', 'æ¬ ã‘ãŸæ•°å­—ã¯èª°ã‹ãŒçŸ¥ã£ã¦ã„ã‚‹'],
      },
      5: {
        leader: ['ã€æŒ‡ä»¤ã€‘æœ€çµ‚å…¥åŠ›ã‚’è¡Œã†', 'è‡ªåˆ†ã¯ä½•ã‚‚çŸ¥ã‚‰ãªã„', '4äººã‹ã‚‰æƒ…å ±ã‚’é›†ã‚ã‚ˆ'],
        decoder: ['ã€æ–­ç‰‡ã€‘ã€Œè§’ã€ã¨ã„ã†æ–‡å­—ã‚’å—ä¿¡', 'æ„å‘³ã¯ä¸æ˜', 'ä»–ã®ãƒ¡ãƒ³ãƒãƒ¼ã®æƒ…å ±ãŒå¿…è¦'],
        investigator: ['ã€å ±å‘Šã€‘è‰²ã®çŸ³æ¿ã‚’ç™ºè¦‹', 'é’ã¨ç·‘ã‚’è¦‹ã¤ã‘ãŸ', 'æ®‹ã‚Šã¯æ¢ç´¢ä¸­'],
        analyst: ['ã€è§£æã€‘æ•°å­—ã‚’ç™ºè¦‹', '3, ?, 5, ?, ?', 'æ¬ ã‘ã¦ã„ã‚‹æ•°å­—ãŒã‚ã‚‹'],
        communicator: ['ã€å‚å—ã€‘é€šä¿¡ã‚’è§£èª­', 'è§£èª­å“¡ãŒã€Œæ³•å‰‡ã®ç¨®é¡ã€ã‚’çŸ¥ã‚‹', 'åˆ†æå“¡ãŒã€Œæ•°å­—ã€ã‚’çŸ¥ã‚‹'],
      },
    };
    return messages[size]?.[roleId] || ['æƒ…å ±ãªã—'];
  };

  // äººæ•°åˆ¥ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ’ãƒ³ãƒˆ
  const getFieldHints = (size, roleId) => {
    const hints = {
      2: {
        leader: ['â–²ã¯1ç•ªç›®', 'â˜…ã¯3ç•ªç›®', 'â—ã¯â– ã‚ˆã‚Šå¾Œã‚'],
        decoder: ['æ•°åˆ—ï¼š3, 4, 5, ?, ?', 'â– ã¯2ç•ªç›®', 'â—†ã¯æœ€å¾Œ'],
      },
      3: {
        leader: ['1ç•ªç›®ã¯3è§’ã®å½¢', '4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹'],
        decoder: ['æ•°åˆ—ï¼š3, 4, 5, 0, 4', 'ã“ã®æ•°åˆ—ãŒé †ç•ªã‚’æ±ºã‚ã‚‹'],
        investigator: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'],
      },
      4: {
        leader: ['ç­”ãˆã¯5ã¤ã®å½¢ã®åˆ—'],
        decoder: ['è§’ã®æ•°ã§é †ç•ªãŒæ±ºã¾ã‚‹', '3ç•ªç›®ã¯5è§’'],
        investigator: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'],
        analyst: ['æ•°åˆ—å®Œæˆï¼š3,4,5,0,4', '4ç•ªç›®ã¯0'],
      },
      5: {
        leader: ['å…¨å“¡ã®æƒ…å ±ã‚’çµ±åˆã›ã‚ˆ'],
        decoder: ['è§’ã®æ•°ãŒé †ç•ªã®æ³•å‰‡'],
        investigator: ['é’=â–² ç·‘=â– ', 'é»„=â˜… èµ¤=â— ç´«=â—†'],
        analyst: ['æ•°åˆ—ï¼š3,4,5,0,4'],
        communicator: ['4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹', 'â– ãŒå…ˆã€â—†ãŒå¾Œ'],
      },
    };
    return hints[size]?.[roleId] || [];
  };

  // å…±é€šãƒ’ãƒ³ãƒˆ
  const commonHints = [
    { location: 'å…¥å£ã®å£', text: '5ã¤ã®å½¢ãŒæ‰‰ã‚’é–‹ã' },
    { location: 'ä¸­å¤®ã®åºŠ', text: 'â–²=3è§’ â– =4è§’ â˜…=5è§’ â—=0è§’ â—†=4è§’' },
    { location: 'æœ¬æ£š', text: 'è§’ã®æ•°ã«æ³¨ç›®ã›ã‚ˆ' },
  ];

  // æ­£è§£ï¼ˆå›³å½¢ã®é †ç•ªï¼‰
  const correctAnswer = ['â–²', 'â– ', 'â˜…', 'â—', 'â—†'];
  const shapes = ['â–²', 'â– ', 'â˜…', 'â—', 'â—†'];

  // å¾Œæ–¹äº’æ›ã®ãŸã‚ã®rolesã‚²ãƒƒã‚¿ãƒ¼
  const roles = getRolesForTeamSize(teamSize);
  const correctNumbers = ['7', '3', '1', '9', '5'];

  // äººæ•°åˆ¥ã®å½¹å‰²å‰²ã‚Šå½“ã¦
  const getRoleAssignments = (memberCount, memberIndex) => {
    if (memberCount >= 5) {
      return [roles[memberIndex % 5]];
    } else if (memberCount === 4) {
      const assignments = [
        [roles[0]], // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
        [roles[1]], // ãƒ‡ãƒ¼ã‚¿
        [roles[2]], // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
        [roles[3], roles[4]] // ã‚·ã‚¹ãƒ†ãƒ  + AI
      ];
      return assignments[memberIndex % 4];
    } else if (memberCount === 3) {
      const assignments = [
        [roles[0], roles[1]], // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ + ãƒ‡ãƒ¼ã‚¿
        [roles[2], roles[3]], // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ + ã‚·ã‚¹ãƒ†ãƒ 
        [roles[4]] // AI
      ];
      return assignments[memberIndex % 3];
    } else {
      const assignments = [
        [roles[0], roles[1], roles[2]], // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ + ãƒ‡ãƒ¼ã‚¿ + ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
        [roles[3], roles[4]] // ã‚·ã‚¹ãƒ†ãƒ  + AI
      ];
      return assignments[memberIndex % 2];
    }
  };

  // ãƒã‚¤ã‚¯ãƒ©é¢¨ã‚¢ãƒã‚¿ãƒ¼ä½œæˆé–¢æ•°
  const createMinecraftAvatar = (roleColor) => {
    const avatarGroup = new THREE.Group();

    const skinColor = 0xffdbac;
    const bodyColor = new THREE.Color(roleColor);
    const pantsColor = 0x3a3a5a;

    // é ­éƒ¨
    const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMaterial = new THREE.MeshStandardMaterial({
      color: skinColor, roughness: 0.8, metalness: 0.1
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    head.castShadow = true;
    avatarGroup.add(head);

    // èƒ´ä½“
    const bodyGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const bodyMaterial = new THREE.MeshStandardMaterial({
      color: bodyColor, roughness: 0.7, metalness: 0.2,
      emissive: bodyColor, emissiveIntensity: 0.15
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.0;
    body.castShadow = true;
    avatarGroup.add(body);

    // è…•
    const armGeometry = new THREE.BoxGeometry(0.15, 0.5, 0.15);
    const armMaterial = new THREE.MeshStandardMaterial({
      color: skinColor, roughness: 0.8, metalness: 0.1
    });
    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.275, 1.0, 0);
    leftArm.castShadow = true;
    avatarGroup.add(leftArm);

    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.275, 1.0, 0);
    rightArm.castShadow = true;
    avatarGroup.add(rightArm);

    // è„š
    const legGeometry = new THREE.BoxGeometry(0.18, 0.5, 0.18);
    const legMaterial = new THREE.MeshStandardMaterial({
      color: pantsColor, roughness: 0.9, metalness: 0.05
    });
    const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.1, 0.4, 0);
    leftLeg.castShadow = true;
    avatarGroup.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
    rightLeg.position.set(0.1, 0.4, 0);
    rightLeg.castShadow = true;
    avatarGroup.add(rightLeg);

    avatarGroup.userData = {
      isAvatar: true, head, body, leftArm, rightArm, leftLeg, rightLeg
    };

    return avatarGroup;
  };

  // å½¹å‰²åãƒ©ãƒ™ãƒ«ä½œæˆé–¢æ•°
  const createRoleLabel = (roleName, color) => {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

    // èƒŒæ™¯
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.beginPath();
    ctx.roundRect(0, 0, 256, 64, 8);
    ctx.fill();

    // æ ç·š
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(0, 0, 256, 64, 8);
    ctx.stroke();

    // ãƒ†ã‚­ã‚¹ãƒˆ
    ctx.font = 'bold 28px "Hiragino Sans", "Meiryo", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = color;
    ctx.fillText(roleName, 128, 32);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const spriteMaterial = new THREE.SpriteMaterial({
      map: texture, transparent: true, depthTest: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.y = 2.0;
    sprite.scale.set(1.2, 0.3, 1);

    return sprite;
  };

  // Supabaseè¨­å®š
  const SUPABASE_URL = 'https://nqvpjmwvrtvbhojeotmx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5xdnBqbXd2cnR2YmhvamVvdG14Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjczNTAxMTksImV4cCI6MjA4MjkyNjExOX0.NbacfvbI6MpuCv1ckTRWQroFrZWugKy9tYwHslaUm70';

  // Supabase APIãƒ˜ãƒ«ãƒ‘ãƒ¼
  const supabase = {
    async getTeam(code) {
      try {
        console.log('getTeam: æ¤œç´¢ã‚³ãƒ¼ãƒ‰:', code);
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code + '&select=*',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        console.log('getTeam: HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:', res.status);
        const data = await res.json();
        console.log('getTeam: ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', data);
        return data && data.length > 0 ? data[0] : null;
      } catch (e) { console.error('getTeam error:', e); return null; }
    },
    async createTeam(code, name, teamData) {
      try {
        console.log('createTeam: ä½œæˆé–‹å§‹:', { code, name, teamData });
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams',
          {
            method: 'POST',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
              'Content-Type': 'application/json',
              'Prefer': 'return=representation'
            },
            body: JSON.stringify({ code: code, name: name, size: teamData.maxMembers, data: teamData })
          }
        );
        console.log('createTeam: HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:', res.status);
        const result = await res.json();
        console.log('createTeam: ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', result);
        // HTTPã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™
        if (!res.ok) {
          return { error: true, status: res.status, ...result };
        }
        return result;
      } catch (e) { console.error('createTeam error:', e); return null; }
    },
    async updateTeam(code, teamData) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code,
          {
            method: 'PATCH',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ data: teamData })
          }
        );
        return res.ok;
      } catch (e) { console.error('updateTeam error:', e); return false; }
    },
    async getAllTeams() {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?select=*&order=created_at.desc',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        return await res.json();
      } catch (e) { console.error('getAllTeams error:', e); return []; }
    },
    async deleteTeam(code) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code,
          {
            method: 'DELETE',
            headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY }
          }
        );
        return res.ok;
      } catch (e) { console.error('deleteTeam error:', e); return false; }
    },
    async getTeamByName(name) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?name=eq.' + encodeURIComponent(name) + '&select=*',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        const data = await res.json();
        return data && data.length > 0 ? data[0] : null;
      } catch (e) { console.error('getTeamByName error:', e); return null; }
    }
  };

  // ãƒãƒ¼ãƒ ä½œæˆ
  const handleCreateTeam = async () => {
    if (!teamName.trim()) return;

    // ãƒãƒ¼ãƒ åã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingByName = await supabase.getTeamByName(teamName.trim());
    if (existingByName) {
      alert('ã“ã®ãƒãƒ¼ãƒ åã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚\nåˆ¥ã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
      return;
    }

    // 4æ¡ã®ãƒ©ãƒ³ãƒ€ãƒ ãªæ•°å­—ï¼ˆ1000-9999ï¼‰
    const teamNum = String(1000 + Math.floor(Math.random() * 9000));

    // ãƒãƒ¼ãƒ ç•ªå·ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existing = await supabase.getTeam(teamNum);
    if (existing) {
      handleCreateTeam();
      return;
    }
    
    const teamData = {
      maxMembers: teamSize,
      members: [],
      lobbyStartTime: null,
      gameStarted: false,
      startTime: null,
      hintsFound: [],
      puzzlesSolved: [],
      completed: false,
      completionTime: null,
      createdAt: Date.now()
    };
    
    const result = await supabase.createTeam(teamNum, teamName, teamData);

    // ãƒãƒ¼ãƒ ä½œæˆãŒå¤±æ•—ã—ãŸå ´åˆ
    // æ³¨æ„: result.codeã¯ãƒãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ãªã®ã§ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã«å«ã‚ãªã„
    if (!result || result.error || result.message || (Array.isArray(result) && result.length === 0)) {
      console.error('ãƒãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:', result);
      const errorMsg = result?.message || 'ãƒãƒ¼ãƒ ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ';
      alert(errorMsg + '\nã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      return;
    }

    // ä½œæˆæˆåŠŸã‚’ç¢ºèª
    console.log('ãƒãƒ¼ãƒ ä½œæˆæˆåŠŸ:', teamNum, result);

    setTeamNumber(teamNum);
    setScreen('waiting');
  };

  // ãƒãƒ¼ãƒ å‚åŠ ï¼ˆç›´æ¥ãƒ­ãƒ“ãƒ¼ã¸ï¼‰
  const handleJoinTeam = async () => {
    if (!teamNumber.trim()) return;

    // æ•°å­—ã®ã¿ã«æ­£è¦åŒ–
    const normalizedNumber = teamNumber.replace(/\D/g, '');
    const team = await supabase.getTeam(normalizedNumber);
    if (!team) {
      alert('ãƒãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒãƒ¼ãƒ ç•ªå·ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      return;
    }

    const teamData = team.data;

    // äººæ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
    if (teamData.members && teamData.members.length >= teamData.maxMembers) {
      alert('ã“ã®ãƒãƒ¼ãƒ ã¯æº€å“¡ã§ã™ï¼ˆ' + teamData.maxMembers + 'äººï¼‰');
      return;
    }

    // ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ãƒã‚§ãƒƒã‚¯
    if (teamData.gameStarted) {
      alert('ã“ã®ãƒãƒ¼ãƒ ã¯ã™ã§ã«ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™');
      return;
    }

    setTeamName(team.name);
    setTeamNumber(normalizedNumber);
    setTeamSize(teamData.maxMembers || 5);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’ç”Ÿæˆã—ã¦ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦è¿½åŠ 
    const oderId = 'P' + Date.now();
    setMyPlayerId(oderId);

    if (!teamData.members) teamData.members = [];
    teamData.members.push({
      oderId: oderId,
      joinTime: Date.now(),
      roleIndex: undefined,
      roleName: undefined
    });

    await supabase.updateTeam(normalizedNumber, teamData);
    setLobbyData(teamData);
    setRoleSelectTimer(45);
    setScreen('lobby');  // ç›´æ¥ãƒ­ãƒ“ãƒ¼ã¸
  };

  // ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆãƒ­ãƒ“ãƒ¼çµŒç”±ï¼‰
  const handleStartGame = async () => {
    if (selectedRole === null) {
      alert('å½¹å‰²ã‚’é¸ã‚“ã§ãã ã•ã„');
      return;
    }
    
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const data = team.data;
    
    const maxMembers = data.maxMembers || teamSize;
    const availableRoles = getRolesForTeamSize(maxMembers);
    
    // æœªé¸æŠè€…ã«è‡ªå‹•å‰²ã‚Šå½“ã¦
    const takenRoles = data.members.filter(function(m) { return m.roleIndex !== undefined; }).map(function(m) { return m.roleIndex; });
    const freeRoles = [];
    for (var i = 0; i < availableRoles.length; i++) {
      if (!takenRoles.includes(i)) freeRoles.push(i);
    }
    
    data.members.forEach(function(member) {
      if (member.roleIndex === undefined && freeRoles.length > 0) {
        member.roleIndex = freeRoles.shift();
        member.roleName = availableRoles[member.roleIndex]?.name;
        member.autoAssigned = true;
      }
    });
    
    data.gameStarted = true;
    data.startTime = Date.now();
    await supabase.updateTeam(teamNumber, data);
    
    setRole(availableRoles[selectedRole]);
    setAssignedRoles([availableRoles[selectedRole]]);
    setTimeLeft(getTeamSettings(teamSize).timeLimit);
    // ãƒãƒ¼ãƒ ã®ãƒ’ãƒ³ãƒˆã‚’èª­ã¿è¾¼ã¿
    if (data.hintsFound) setHintsFound(data.hintsFound);
    setShowMessage(true);
    setTimerStarted(true);
    setScreen('game');
  };

  // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ãƒãƒ¼ãƒ ã®hintsFoundã‚’èª­ã¿è¾¼ã‚€
  const loadTeamHints = async () => {
    try {
      const team = await supabase.getTeam(teamNumber);
      if (team && team.data && team.data.hintsFound) {
        setHintsFound(team.data.hintsFound);
      }
    } catch (e) { console.error('loadTeamHints error:', e); }
  };

  // è‡ªåˆ†ã®ä½ç½®ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
  const updateMyPosition = async () => {
    if (!teamNumber || !myPlayerId) return;
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;
      const myEntry = data.members.find(m => m.oderId === myPlayerId);
      if (myEntry) {
        const player = playerRef.current;
        myEntry.position = {
          x: Math.round(player.x * 100) / 100,
          z: Math.round(player.z * 100) / 100,
          rotation: Math.round(player.rotation * 100) / 100,
          lastUpdate: Date.now()
        };
        await supabase.updateTeam(teamNumber, data);
      }
    } catch (e) { console.error('updateMyPosition error:', e); }
  };

  // ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã¨ãƒ’ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—
  const fetchOtherPlayers = async () => {
    if (!teamNumber || !myPlayerId) return;
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;

      // ãƒãƒ¼ãƒ ã®hintsFoundã‚’åŒæœŸ
      if (data.hintsFound && data.hintsFound.length > 0) {
        setHintsFound(prev => {
          const merged = [...new Set([...prev, ...data.hintsFound])];
          return merged.length !== prev.length ? merged : prev;
        });
      }

      data.members.forEach(member => {
        if (member.oderId === myPlayerId) return;
        if (!member.position) return;

        const existing = otherPlayersRef.current[member.oderId];
        if (existing) {
          existing.target = { ...member.position };
        } else {
          otherPlayersRef.current[member.oderId] = {
            current: { ...member.position },
            target: { ...member.position },
            roleIndex: member.roleIndex,
            roleName: member.roleName
          };
        }
      });

      // åˆ‡æ–­ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤
      const activeIds = data.members.map(m => m.oderId);
      Object.keys(otherPlayersRef.current).forEach(id => {
        if (!activeIds.includes(id)) {
          delete otherPlayersRef.current[id];
        }
      });
    } catch (e) { console.error('fetchOtherPlayers error:', e); }
  };

  // äººæ•°åˆ¥ï¼šèª°ãŒã©ã®ãƒ’ãƒ³ãƒˆã‚’è¦‹ã‚Œã‚‹ã‹
  const getHintPermissions = (size, roleId) => {
    // hintId: 0=ãƒªãƒ¼ãƒ€ãƒ¼, 1=è§£èª­å“¡, 2=èª¿æŸ»å“¡, 3=åˆ†æå“¡, 4=é€šä¿¡å“¡ ã®ãƒ¢ãƒ‹ãƒ¥ãƒ¡ãƒ³ãƒˆ
    const permissions = {
      2: {
        leader: [0, 1, 2],    // ãƒªãƒ¼ãƒ€ãƒ¼ã¯3ã¤è¦‹ã‚Œã‚‹
        decoder: [3, 4],       // è§£èª­å“¡ã¯2ã¤è¦‹ã‚Œã‚‹
      },
      3: {
        leader: [0, 1],        // ãƒªãƒ¼ãƒ€ãƒ¼ã¯2ã¤
        decoder: [2, 3],       // è§£èª­å“¡ã¯2ã¤
        investigator: [4],     // èª¿æŸ»å“¡ã¯1ã¤
      },
      4: {
        leader: [0],
        decoder: [1, 2],       // è§£èª­å“¡ã¯2ã¤
        investigator: [3],
        analyst: [4],
      },
      5: {
        leader: [0],
        decoder: [1],
        investigator: [2],
        analyst: [3],
        communicator: [4],
      },
    };
    return permissions[size]?.[roleId] || [];
  };

  // ãƒ’ãƒ³ãƒˆå–å¾—ï¼ˆåå°„ç¥çµŒã‚²ãƒ¼ãƒ çµŒç”±ï¼‰
  const collectHint = async (hintId) => {
    const hintInfo = [
      { name: 'ãƒªãƒ¼ãƒ€ãƒ¼', color: '#ffd700', roleId: 'leader' },
      { name: 'è§£èª­å“¡', color: '#ff6b6b', roleId: 'decoder' },
      { name: 'èª¿æŸ»å“¡', color: '#4ecdc4', roleId: 'investigator' },
      { name: 'åˆ†æå“¡', color: '#95e1d3', roleId: 'analyst' },
      { name: 'é€šä¿¡å“¡', color: '#dda0dd', roleId: 'communicator' }
    ];
    const info = hintInfo[hintId] || { name: 'ä¸æ˜', color: '#ffffff', roleId: 'unknown' };

    // è‡ªåˆ†ãŒã“ã®ãƒ’ãƒ³ãƒˆã‚’è¦‹ã‚Œã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆäººæ•°ãƒ™ãƒ¼ã‚¹ï¼‰
    const myPermissions = role ? getHintPermissions(teamSize, role.id) : [];
    const canSeeHint = myPermissions.includes(hintId);

    // hintIdã‚’æ•°å€¤ã«çµ±ä¸€
    const numHintId = Number(hintId);

    // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ï¼ˆRefçµŒç”±ã§æœ€æ–°å€¤ï¼‰ã¨Supabaseã®ä¸¡æ–¹ã‚’ãƒã‚§ãƒƒã‚¯
    const localHints = (hintsFoundRef.current || []).map(Number);
    let teamHintsFound = [...localHints];
    try {
      const team = await supabase.getTeam(teamNumber);
      console.log('collectHint: Supabaseãƒ‡ãƒ¼ã‚¿', { teamData: team?.data, hintsFound: team?.data?.hintsFound });
      if (team && team.data && team.data.hintsFound && Array.isArray(team.data.hintsFound)) {
        // æ•°å€¤ã«çµ±ä¸€ã—ã¦ãƒãƒ¼ã‚¸
        const supabaseHints = team.data.hintsFound.map(Number);
        teamHintsFound = [...new Set([...localHints, ...supabaseHints])];
        // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚æ›´æ–°
        setHintsFound(teamHintsFound);
        hintsFoundRef.current = teamHintsFound;
      }
    } catch (e) { console.error('fetchTeamHints error:', e); }

    console.log('collectHint: check', { localHints, teamHintsFound, numHintId, includes: teamHintsFound.includes(numHintId) });
    
    // ãƒ’ãƒ³ãƒˆã®å†…å®¹ã‚’å–å¾—ï¼ˆäººæ•°ã¨ãƒ¢ãƒ‹ãƒ¥ãƒ¡ãƒ³ãƒˆIDã«å¿œã˜ãŸå†…å®¹ï¼‰
    const getHintContent = function(hId) {
      // äººæ•°åˆ¥ã®ãƒ’ãƒ³ãƒˆå†…å®¹ï¼ˆå„ãƒ¢ãƒ‹ãƒ¥ãƒ¡ãƒ³ãƒˆå°‚ç”¨ï¼‰
      var contents = {
        2: {
          // ãƒªãƒ¼ãƒ€ãƒ¼ãŒè¦‹ã‚Œã‚‹3ã¤
          0: ['â–²ã¯1ç•ªç›®'],
          1: ['â˜…ã¯3ç•ªç›®'],
          2: ['â—ã¯â– ã‚ˆã‚Šå¾Œã‚'],
          // è§£èª­å“¡ãŒè¦‹ã‚Œã‚‹2ã¤
          3: ['æ•°åˆ—ï¼š3, 4, 5, ?, ?', 'â– ã¯2ç•ªç›®'],
          4: ['â—†ã¯æœ€å¾Œ', '?ã¯0ã¨4'],
        },
        3: {
          // ãƒªãƒ¼ãƒ€ãƒ¼ãŒè¦‹ã‚Œã‚‹2ã¤
          0: ['1ç•ªç›®ã¯3è§’ã®å½¢'],
          1: ['4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹'],
          // è§£èª­å“¡ãŒè¦‹ã‚Œã‚‹2ã¤
          2: ['æ•°åˆ—ï¼š3, 4, 5, 0, 4'],
          3: ['ã“ã®æ•°åˆ—ãŒé †ç•ªã‚’æ±ºã‚ã‚‹'],
          // èª¿æŸ»å“¡ãŒè¦‹ã‚Œã‚‹1ã¤
          4: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'],
        },
        4: {
          // ãƒªãƒ¼ãƒ€ãƒ¼1ã¤
          0: ['ç­”ãˆã¯5ã¤ã®å½¢ã®åˆ—'],
          // è§£èª­å“¡2ã¤
          1: ['è§’ã®æ•°ã§é †ç•ªãŒæ±ºã¾ã‚‹'],
          2: ['3ç•ªç›®ã¯5è§’'],
          // èª¿æŸ»å“¡1ã¤
          3: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'],
          // åˆ†æå“¡1ã¤
          4: ['æ•°åˆ—å®Œæˆï¼š3,4,5,0,4', '4ç•ªç›®ã¯0'],
        },
        5: {
          0: ['å…¨å“¡ã®æƒ…å ±ã‚’çµ±åˆã›ã‚ˆ'],
          1: ['è§’ã®æ•°ãŒé †ç•ªã®æ³•å‰‡'],
          2: ['é’=â–² ç·‘=â– ', 'é»„=â˜… èµ¤=â— ç´«=â—†'],
          3: ['æ•°åˆ—ï¼š3,4,5,0,4'],
          4: ['4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹', 'â– ãŒå…ˆã€â—†ãŒå¾Œ'],
        },
      };
      return contents[teamSize]?.[hId] || ['ãƒ’ãƒ³ãƒˆãªã—'];
    };
    
    // èª°ãŒè¦‹ã‚Œã‚‹ãƒ’ãƒ³ãƒˆã‹è¡¨ç¤ºç”¨
    const getWhoCanSee = function(hId) {
      var whoList = [];
      var perms = {
        2: { leader: [0,1,2], decoder: [3,4] },
        3: { leader: [0,1], decoder: [2,3], investigator: [4] },
        4: { leader: [0], decoder: [1,2], investigator: [3], analyst: [4] },
        5: { leader: [0], decoder: [1], investigator: [2], analyst: [3], communicator: [4] },
      };
      var names = { leader: 'ãƒªãƒ¼ãƒ€ãƒ¼', decoder: 'è§£èª­å“¡', investigator: 'èª¿æŸ»å“¡', analyst: 'åˆ†æå“¡', communicator: 'é€šä¿¡å“¡' };
      var sizePerms = perms[teamSize] || {};
      for (var r in sizePerms) {
        if (sizePerms[r].includes(hId)) {
          whoList.push(names[r]);
        }
      }
      return whoList.join('ã€') || 'ä¸æ˜';
    };

    // ãƒãƒ¼ãƒ ã®èª°ã‹ãŒã‚¯ãƒªã‚¢æ¸ˆã¿ãªã‚‰ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤ºï¼ˆåå°„ã‚²ãƒ¼ãƒ ä¸è¦ï¼‰
    if (teamHintsFound.includes(numHintId)) {
      // æ—¢ã«å–å¾—æ¸ˆã¿ã®å ´åˆ
      if (canSeeHint) {
        var fieldHints = getHintContent(hintId);
        setCurrentHint({
          title: 'ãƒ’ãƒ³ãƒˆ #' + (hintId + 1) + 'ï¼ˆå–å¾—æ¸ˆã¿ï¼‰',
          message: fieldHints.join('\n'),
          color: info.color
        });
      } else {
        setCurrentHint({
          title: 'ãƒ’ãƒ³ãƒˆ #' + (hintId + 1) + 'ï¼ˆå–å¾—æ¸ˆã¿ï¼‰',
          message: 'ğŸ”’ ã“ã®ãƒ’ãƒ³ãƒˆã¯ã€Œ' + getWhoCanSee(hintId) + 'ã€ãŒè¦‹ã‚Œã¾ã™ã€‚\n\nãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã«å†…å®¹ã‚’ç¢ºèªã—ã¦ã‚‚ã‚‰ã„ã¾ã—ã‚‡ã†ï¼',
          color: '#666666'
        });
      }
      setShowHintModal(true);
      return;
    }
    
    // åå°„ç¥çµŒã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ï¼ˆèª°ã§ã‚‚ã‚¯ãƒªã‚¢å¯èƒ½ï¼‰
    var difficulty = getDifficultyFromTeamSize(teamSize);
    var canSee = canSeeHint;
    var hContent = getHintContent(hintId);
    var whoSees = getWhoCanSee(hintId);
    
    // ã‚¯ãƒªã‚¢æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
    var onComplete = async function() {
      // hintIdã‚’æ•°å€¤ã«çµ±ä¸€
      var numId = Number(hintId);

      // ãƒ’ãƒ³ãƒˆå–å¾—ã‚’è¨˜éŒ²ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã¨Refä¸¡æ–¹æ›´æ–°ï¼‰
      var currentHints = (hintsFoundRef.current || []).map(Number);
      var newHints = currentHints.slice();
      if (!newHints.includes(numId)) {
        newHints.push(numId);
      }
      hintsFoundRef.current = newHints;  // Refã‚’å³åº§ã«æ›´æ–°
      setHintsFound(newHints);  // çŠ¶æ…‹ã‚‚æ›´æ–°

      // Supabaseã«ã‚‚ä¿å­˜ï¼ˆãƒãƒ¼ãƒ å…±æœ‰ï¼‰
      try {
        console.log('onComplete: ãƒ’ãƒ³ãƒˆä¿å­˜é–‹å§‹', { numId, teamNumber });
        const team = await supabase.getTeam(teamNumber);
        console.log('onComplete: ç¾åœ¨ã®ãƒãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿', team);
        if (team) {
          const data = team.data || {};
          if (!data.hintsFound) data.hintsFound = [];
          // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚‚æ•°å€¤ã«çµ±ä¸€ã—ã¦ãƒã‚§ãƒƒã‚¯
          var existingHints = data.hintsFound.map(Number);
          if (!existingHints.includes(numId)) {
            data.hintsFound = [...existingHints, numId];
            console.log('onComplete: ä¿å­˜ã™ã‚‹hintsFound', data.hintsFound);
            const updateResult = await supabase.updateTeam(teamNumber, data);
            console.log('onComplete: ä¿å­˜çµæœ', updateResult);
          } else {
            console.log('onComplete: æ—¢ã«ä¿å­˜æ¸ˆã¿', data.hintsFound);
          }
        }
      } catch (e) { console.error('saveHintToSupabase error:', e); }

      // ãƒ’ãƒ³ãƒˆè¡¨ç¤º
      if (canSee) {
        setCurrentHint({
          title: 'ãƒ’ãƒ³ãƒˆ #' + (hintId + 1),
          message: hContent.join('\n'),
          color: info.color
        });
      } else {
        setCurrentHint({
          title: 'ãƒ’ãƒ³ãƒˆ #' + (hintId + 1),
          message: 'âœ… ãƒ’ãƒ³ãƒˆã‚’è§£é™¤ã—ã¾ã—ãŸï¼\n\nğŸ”’ ã“ã®ãƒ’ãƒ³ãƒˆã¯ã€Œ' + whoSees + 'ã€ãŒè¦‹ã‚Œã¾ã™ã€‚\n\nãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã«å†…å®¹ã‚’ç¢ºèªã—ã¦ã‚‚ã‚‰ã„ã¾ã—ã‚‡ã†ï¼',
          color: '#666666'
        });
      }
      setShowHintModal(true);
    };
    
    var onClose = function() {
      var existing = document.getElementById('reflex-game-container');
      if (existing) existing.remove();
    };
    
    startReflexGame(difficulty, 'hint', onComplete, onClose);
  };

  // æœ€çµ‚ãƒ‘ã‚ºãƒ«ã‚’é–‹å§‹ï¼ˆåå°„ã‚²ãƒ¼ãƒ å¾Œã«ãƒ‘ã‚ºãƒ«å…¥åŠ›ç”»é¢ã‚’è¡¨ç¤ºï¼‰
  const startFinalPuzzle = () => {
    const requiredHints = getTeamSettings(teamSize).hintsRequired;
    if (hintsFound.length < requiredHints) {
      setPuzzleError('ã¾ã å…¨ã¦ã®ãƒ’ãƒ³ãƒˆã‚’é›†ã‚ã¦ã„ã¾ã›ã‚“ï¼ˆ' + hintsFound.length + '/' + requiredHints + 'ï¼‰');
      return;
    }
    setShowPuzzleModal(false);

    const onComplete = function() {
      // åå°„ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å¾Œã€ãƒ‘ã‚ºãƒ«å…¥åŠ›ç”»é¢ã‚’è¡¨ç¤º
      setPuzzleInput(['', '', '', '', '']);
      setPuzzleError('');
      setShowFinalInputModal(true);
    };

    const onClose = function() {
      var existing = document.getElementById('reflex-game-container');
      if (existing) existing.remove();
    };

    startReflexGame(5, 'final', onComplete, onClose);
  };

  // ãƒ‘ã‚ºãƒ«å›ç­”ã‚’ãƒã‚§ãƒƒã‚¯
  const checkPuzzleAnswer = async () => {
    // æ­£è§£: â–² â–  â˜… â— â—†ï¼ˆä¸‰è§’ã€å››è§’ã€æ˜Ÿã€ä¸¸ã€ã²ã—å½¢ï¼‰
    const correctAnswers = ['â–²', 'â– ', 'â˜…', 'â—', 'â—†'];
    const userAnswers = puzzleInput.map(s => s.trim());

    // å…¨ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (userAnswers.some(a => a === '')) {
      setPuzzleError('å…¨ã¦ã®æ¬„ã«å½¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      return;
    }

    // æ­£è§£ãƒã‚§ãƒƒã‚¯
    const isCorrect = userAnswers.every((ans, idx) => ans === correctAnswers[idx]);

    if (isCorrect) {
      setShowFinalInputModal(false);
      setGameCompleted(true);
      const finalTime = getTeamSettings(teamSize).timeLimit - timeLeft;
      setCompletionTime(finalTime);

      // Supabaseã«å®Œäº†ã‚’è¨˜éŒ²
      try {
        const team = await supabase.getTeam(teamNumber);
        if (team) {
          const data = team.data || {};
          data.completed = true;
          data.completionTime = finalTime;
          await supabase.updateTeam(teamNumber, data);
        }
      } catch (e) { console.error('saveCompletion error:', e); }

      setScreen('complete');
    } else {
      setPuzzleError('ä¸æ­£è§£ã§ã™ã€‚ãƒ’ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦å†åº¦å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
    }
  };

  // hintsFoundRefã‚’å¸¸ã«æœ€æ–°ã«ä¿ã¤
  useEffect(() => {
    hintsFoundRef.current = hintsFound;
  }, [hintsFound]);

  // ã‚¿ã‚¤ãƒãƒ¼
  useEffect(() => {
    if (timerStarted && timeLeft > 0 && screen === 'game') {
      const timer = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            setScreen('complete');
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [timerStarted, timeLeft, screen]);

  // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ï¼ˆãƒœã‚¿ãƒ³ã¨ã‚­ãƒ¼ã®ä¸¡æ–¹ã‹ã‚‰å‘¼ã³å‡ºã—å¯èƒ½ï¼‰
  const handleInteraction = () => {
    if (nearbyObject) {
      if (nearbyObject.type === 'hint') {
        collectHint(nearbyObject.id);
      } else if (nearbyObject.type === 'puzzle') {
        // ä¸­å¤®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¯ãƒªãƒ¼ãƒ€ãƒ¼ã®ã¿æ“ä½œå¯èƒ½
        if (role?.id !== 'leader') {
          alert('ä¸­å¤®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¯ãƒªãƒ¼ãƒ€ãƒ¼ã®ã¿æ“ä½œã§ãã¾ã™ã€‚\nãƒªãƒ¼ãƒ€ãƒ¼ã«æ“ä½œã‚’ä¾é ¼ã—ã¦ãã ã•ã„ã€‚');
          return;
        }
        setShowPuzzleModal(true);
      }
    }
  };

  // ã‚­ãƒ¼å…¥åŠ›ã§ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
  useEffect(() => {
    const onKeyDown = function(e) {
      if (e.key.toLowerCase() === 'e') {
        handleInteraction();
      }
    };
    
    window.addEventListener('keydown', onKeyDown);
    return function() { window.removeEventListener('keydown', onKeyDown); };
  }, [nearbyObject, hintsFound]);

  // Three.js ã‚·ãƒ¼ãƒ³
  useEffect(() => {
    if (screen !== 'game' || !mountRef.current) return;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000510, 10, 50);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
    const ambientLight = new THREE.AmbientLight(0x4a5f8f, 0.4);
    scene.add(ambientLight);

    const topLight = new THREE.PointLight(0xadd8e6, 2, 30);
    topLight.position.set(0, 15, 0);
    topLight.castShadow = true;
    topLight.shadow.mapSize.width = 2048;
    topLight.shadow.mapSize.height = 2048;
    scene.add(topLight);

    const blueLight1 = new THREE.PointLight(0x00ffff, 1.5, 20);
    blueLight1.position.set(-10, 3, -10);
    scene.add(blueLight1);

    const blueLight2 = new THREE.PointLight(0x00ffff, 1.5, 20);
    blueLight2.position.set(10, 3, -10);
    scene.add(blueLight2);

    const purpleLight = new THREE.PointLight(0xff00ff, 1.2, 15);
    purpleLight.position.set(0, 2, -15);
    scene.add(purpleLight);

    const greenLight = new THREE.PointLight(0x00ff88, 1, 12);
    greenLight.position.set(-8, 2, 0);
    scene.add(greenLight);

    // åºŠ
    const floorGeometry = new THREE.CircleGeometry(18, 64);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a3550,
      metalness: 0.3,
      roughness: 0.7
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // é­”æ³•é™£
    const circleGeometry = new THREE.RingGeometry(8, 8.2, 64);
    const circleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide
    });
    const magicCircle = new THREE.Mesh(circleGeometry, circleMaterial);
    magicCircle.rotation.x = -Math.PI / 2;
    magicCircle.position.y = 0.02;
    scene.add(magicCircle);

    const innerCircle = new THREE.Mesh(
      new THREE.RingGeometry(5, 5.15, 64),
      circleMaterial
    );
    innerCircle.rotation.x = -Math.PI / 2;
    innerCircle.position.y = 0.03;
    scene.add(innerCircle);

    // å…­èŠ’æ˜Ÿ
    const starPoints = [];
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
      starPoints.push(new THREE.Vector3(
        Math.cos(angle) * 6,
        0.04,
        Math.sin(angle) * 6
      ));
    }
    for (let i = 0; i < 6; i++) {
      const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        starPoints[i],
        starPoints[(i + 2) % 6]
      ]);
      const lineMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.7
      });
      const line = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(line);
    }

    // å£
    const wallSegments = 32;
    for (let i = 0; i < wallSegments; i++) {
      const angle = (i / wallSegments) * Math.PI * 2;
      const wallGeometry = new THREE.BoxGeometry(2, 12, 0.5);
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a2e,
        metalness: 0.2,
        roughness: 0.8
      });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.x = Math.cos(angle) * 17;
      wall.position.z = Math.sin(angle) * 17;
      wall.position.y = 6;
      wall.rotation.y = -angle;
      wall.castShadow = true;
      wall.receiveShadow = true;
      scene.add(wall);
    }

    // æœ¨ç›®ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
    const createWoodTexture = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createLinearGradient(0, 0, 512, 0);
      gradient.addColorStop(0, '#3a2515');
      gradient.addColorStop(0.5, '#4a3020');
      gradient.addColorStop(1, '#3a2515');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      for (let i = 0; i < 80; i++) {
        ctx.strokeStyle = `rgba(${30 + Math.random() * 20}, ${20 + Math.random() * 15}, ${10 + Math.random() * 10}, ${0.4 + Math.random() * 0.3})`;
        ctx.lineWidth = 0.5 + Math.random() * 2;
        ctx.beginPath();
        const y = Math.random() * 512;
        const variance = Math.random() * 40 - 20;
        ctx.moveTo(0, y);
        ctx.bezierCurveTo(170, y + variance, 340, y - variance, 512, y);
        ctx.stroke();
      }
      
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const radius = 10 + Math.random() * 20;
        const knotGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        knotGradient.addColorStop(0, 'rgba(20, 15, 10, 0.6)');
        knotGradient.addColorStop(1, 'rgba(20, 15, 10, 0)');
        ctx.fillStyle = knotGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    };

    const createBookTexture = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      const colors = ['#2a4a7a', '#4a2a6a', '#5a3a2a', '#2a5a4a', '#6a4a2a', '#3a3a5a'];
      const baseColor = colors[Math.floor(Math.random() * colors.length)];
      ctx.fillStyle = baseColor;
      ctx.fillRect(0, 0, 128, 256);
      
      ctx.strokeStyle = 'rgba(200, 180, 120, 0.5)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
        ctx.beginPath();
        ctx.moveTo(10, 60 + i * 30);
        ctx.lineTo(118, 60 + i * 30);
        ctx.stroke();
      }
      
      const edgeGradient = ctx.createLinearGradient(0, 0, 20, 0);
      edgeGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
      edgeGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = edgeGradient;
      ctx.fillRect(0, 0, 20, 256);
      
      return new THREE.CanvasTexture(canvas);
    };

    const woodTexture = createWoodTexture();
    woodTexture.repeat.set(1, 2);

    // æœ¬æ£š
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      
      const shelfGeometry = new THREE.BoxGeometry(3.5, 8, 0.2);
      const shelfMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture.clone(),
        color: 0x5a4530,
        metalness: 0.05,
        roughness: 0.95
      });
      const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
      shelf.position.x = Math.cos(angle) * 15.2;
      shelf.position.z = Math.sin(angle) * 15.2;
      shelf.position.y = 4;
      shelf.rotation.y = -angle;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      scene.add(shelf);

      const sideGeometry = new THREE.BoxGeometry(0.15, 8, 0.6);
      const sideMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture.clone(),
        color: 0x4a3520,
        metalness: 0.05,
        roughness: 0.95
      });
      
      const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
      leftSide.position.x = shelf.position.x + Math.cos(angle - Math.PI / 2) * 1.75;
      leftSide.position.z = shelf.position.z + Math.sin(angle - Math.PI / 2) * 1.75;
      leftSide.position.y = 4;
      leftSide.rotation.y = -angle;
      leftSide.castShadow = true;
      scene.add(leftSide);
      
      const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
      rightSide.position.x = shelf.position.x + Math.cos(angle + Math.PI / 2) * 1.75;
      rightSide.position.z = shelf.position.z + Math.sin(angle + Math.PI / 2) * 1.75;
      rightSide.position.y = 4;
      rightSide.rotation.y = -angle;
      rightSide.castShadow = true;
      scene.add(rightSide);

      for (let level = 0; level < 5; level++) {
        const shelfPlateGeometry = new THREE.BoxGeometry(3.3, 0.08, 0.55);
        const plateTexture = woodTexture.clone();
        plateTexture.repeat.set(2, 1);
        const shelfPlateMaterial = new THREE.MeshStandardMaterial({
          map: plateTexture,
          color: 0x5a4a35,
          metalness: 0.05,
          roughness: 0.9
        });
        const shelfPlate = new THREE.Mesh(shelfPlateGeometry, shelfPlateMaterial);
        shelfPlate.position.x = shelf.position.x;
        shelfPlate.position.z = shelf.position.z;
        shelfPlate.position.y = 0.8 + level * 1.6;
        shelfPlate.rotation.y = -angle;
        shelfPlate.castShadow = true;
        shelfPlate.receiveShadow = true;
        scene.add(shelfPlate);
      }

      // æœ¬ã‚’é…ç½®
      for (let j = 0; j < 5; j++) {
        const booksPerShelf = 12; // å„æ£šã«12å†Š
        const shelfY = 1.1 + j * 1.6;
        
        for (let k = 0; k < booksPerShelf; k++) {
          const bookTexture = createBookTexture();
          const bookWidth = 0.12;
          const bookHeight = 0.5 + Math.random() * 0.2;
          const bookDepth = 0.35;
          const bookGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth);
          const bookMaterial = new THREE.MeshStandardMaterial({
            map: bookTexture,
            emissive: Math.random() > 0.85 ? 0x001133 : 0x000000,
            emissiveIntensity: 0.3,
            metalness: 0.1,
            roughness: 0.85
          });
          const book = new THREE.Mesh(bookGeometry, bookMaterial);
          
          // æœ¬ã‚’æ¨ªã«ä¸¦ã¹ã‚‹ï¼ˆ-1.4 ã‹ã‚‰ 1.4 ã®ç¯„å›²ï¼‰
          const xOffset = (k - (booksPerShelf - 1) / 2) * 0.24;
          
          // æœ¬æ£šã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ç³»ã§é…ç½®ã—ã¦ã‹ã‚‰å›è»¢
          // æœ¬æ£šã¯ angle ã®æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹
          // æœ¬ã¯æ£šæ¿ã®ä¸Šã€èƒŒæ¿ã®æ‰‹å‰ã«é…ç½®
          const localX = xOffset;  // æ¨ªæ–¹å‘
          const localZ = 0.15;     // æ‰‹å‰æ–¹å‘ï¼ˆä¸­å¿ƒã«å‘ã‹ã£ã¦ï¼‰
          
          // å›è»¢è¡Œåˆ—ã‚’é©ç”¨
          const cosA = Math.cos(angle);
          const sinA = Math.sin(angle);
          
          // æœ¬æ£šã®ä¸­å¿ƒä½ç½®
          const shelfCenterX = Math.cos(angle) * 15.2;
          const shelfCenterZ = Math.sin(angle) * 15.2;
          
          // ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
          // æœ¬æ£šã®ãƒ­ãƒ¼ã‚«ãƒ«Xè»¸ã¯æ¥ç·šæ–¹å‘ã€ãƒ­ãƒ¼ã‚«ãƒ«Zè»¸ã¯æ³•ç·šæ–¹å‘ï¼ˆä¸­å¿ƒå‘ãï¼‰
          book.position.x = shelfCenterX - sinA * localX - cosA * localZ;
          book.position.z = shelfCenterZ + cosA * localX - sinA * localZ;
          book.position.y = shelfY;
          book.rotation.y = -angle;
          book.castShadow = true;
          book.receiveShadow = true;
          scene.add(book);
        }
      }
    }

    // ãƒ’ãƒ³ãƒˆã‚¯ãƒªã‚¹ã‚¿ãƒ«ï¼ˆå„å½¹å‰²ã®è‰²ã§ã‚«ãƒ©ãƒ•ãƒ«ã«ï¼‰
    const hintColors = [
      { x: -8, z: -8, color: '#ffd700', name: 'ãƒªãƒ¼ãƒ€ãƒ¼', height: 0.8 },      // é‡‘
      { x: 8, z: -8, color: '#ff6b6b', name: 'è§£èª­å“¡', height: 0.8 },        // èµ¤
      { x: -10, z: 0, color: '#4ecdc4', name: 'èª¿æŸ»å“¡', height: 0.8 },       // é’ç·‘
      { x: 10, z: 0, color: '#95e1d3', name: 'åˆ†æå“¡', height: 0.8 },        // è–„ç·‘
      { x: 0, z: -12, color: '#dda0dd', name: 'é€šä¿¡å“¡', height: 0.8 }        // ç´«
    ];

    hintObjectsRef.current = [];

    hintColors.forEach((pos, idx) => {
      const crystalColor = pos.color;
      
      const pedestalGeometry = new THREE.CylinderGeometry(0.8, 1, 0.5, 8);
      const pedestalMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a3550,
        metalness: 0.7,
        roughness: 0.3
      });
      const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
      pedestal.position.set(pos.x, 0.25, pos.z);
      pedestal.castShadow = true;
      pedestal.receiveShadow = true;
      scene.add(pedestal);

      const crystalGeometry = new THREE.OctahedronGeometry(0.5, 0);
      const crystalMaterial = new THREE.MeshStandardMaterial({
        color: crystalColor,
        emissive: crystalColor,
        emissiveIntensity: 1,
        metalness: 0.8,
        roughness: 0.2,
        transparent: true,
        opacity: 0.9
      });
      const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
      crystal.position.set(pos.x, pos.height, pos.z);
      crystal.castShadow = true;
      crystal.userData = { 
        type: 'hint', 
        id: idx, 
        name: pos.name,
        baseY: pos.height 
      };
      scene.add(crystal);
      
      hintObjectsRef.current.push({
        mesh: crystal,
        position: { x: pos.x, z: pos.z },
        type: 'hint',
        id: idx
      });

      const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: crystalColor,
        transparent: true,
        opacity: 0.2
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(crystal.position);
      glow.userData = { isGlow: true, crystalId: idx };
      scene.add(glow);

      const crystalLight = new THREE.PointLight(crystalColor, 1, 8);
      crystalLight.position.copy(crystal.position);
      scene.add(crystalLight);

      const runeGeometry = new THREE.RingGeometry(1, 1.1, 32);
      const runeMaterial = new THREE.MeshBasicMaterial({
        color: crystalColor,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      const rune = new THREE.Mesh(runeGeometry, runeMaterial);
      rune.rotation.x = -Math.PI / 2;
      rune.position.set(pos.x, 0.01, pos.z);
      rune.userData = { isRune: true, crystalId: idx };
      scene.add(rune);
    });

    // ä¸­å¤®ã‚³ãƒ³ã‚½ãƒ¼ãƒ« - ç¾ã—ã„TorusKnotã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    const consoleBaseGeometry = new THREE.CylinderGeometry(2, 2.5, 0.4, 32);
    const consoleBaseMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a2540,
      metalness: 0.9,
      roughness: 0.1
    });
    const consoleBase = new THREE.Mesh(consoleBaseGeometry, consoleBaseMaterial);
    consoleBase.position.set(0, 0.2, 0);
    consoleBase.castShadow = true;
    consoleBase.receiveShadow = true;
    scene.add(consoleBase);

    // å°åº§ã®è£…é£¾ãƒªãƒ³ã‚°
    const baseRingGeometry = new THREE.TorusGeometry(2.2, 0.08, 16, 64);
    const baseRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.8,
      metalness: 1.0,
      roughness: 0.0
    });
    const baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
    baseRing.position.set(0, 0.4, 0);
    baseRing.rotation.x = Math.PI / 2;
    scene.add(baseRing);

    // ãƒ¡ã‚¤ãƒ³ã®TorusKnotã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    const torusKnotGeometry = new THREE.TorusKnotGeometry(1, 0.35, 128, 32, 2, 3);
    const torusKnotMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 1.0,
      roughness: 0.0,
      envMapIntensity: 1.5
    });
    const torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);
    torusKnot.position.set(0, 2.2, 0);
    torusKnot.castShadow = true;
    torusKnot.userData = { type: 'puzzle', id: 0, isTorusKnot: true };
    scene.add(torusKnot);

    consoleRef.current = {
      position: { x: 0, z: 0 },
      type: 'puzzle',
      id: 0
    };

    // TorusKnotã®å‘¨ã‚Šã®ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    const glowSphereGeometry = new THREE.SphereGeometry(1.8, 32, 32);
    const glowSphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
      side: THREE.BackSide
    });
    const glowSphere = new THREE.Mesh(glowSphereGeometry, glowSphereMaterial);
    glowSphere.position.set(0, 2.2, 0);
    glowSphere.userData = { isConsoleGlow: true };
    scene.add(glowSphere);

    // æµ®éŠã™ã‚‹å¤–å´ãƒªãƒ³ã‚°ï¼ˆ3ã¤ï¼‰
    const orbitRingGeometry = new THREE.TorusGeometry(1.8, 0.03, 16, 64);
    const orbitRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1.2,
      metalness: 1.0,
      roughness: 0.0,
      transparent: true,
      opacity: 0.9
    });
    
    const orbitRing1 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial);
    orbitRing1.position.set(0, 2.2, 0);
    orbitRing1.userData = { isOrbitRing: true, id: 0 };
    scene.add(orbitRing1);

    const orbitRing2 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial.clone());
    orbitRing2.position.set(0, 2.2, 0);
    orbitRing2.userData = { isOrbitRing: true, id: 1 };
    scene.add(orbitRing2);

    const orbitRing3 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial.clone());
    orbitRing3.position.set(0, 2.2, 0);
    orbitRing3.userData = { isOrbitRing: true, id: 2 };
    scene.add(orbitRing3);

    // ä¸­å¿ƒã‹ã‚‰æ”¾å°„ã™ã‚‹å…‰ã®ãƒ“ãƒ¼ãƒ ï¼ˆæŸ±ï¼‰
    const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6, 8);
    const beamMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.3
    });
    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
    beam.position.set(0, 2.2, 0);
    scene.add(beam);

    // ç’°å¢ƒãƒãƒƒãƒ—é¢¨ã®ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ï¼ˆç–‘ä¼¼åå°„ç”¨ï¼‰
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
    cubeRenderTarget.texture.type = THREE.HalfFloatType;
    
    // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆï¼ˆTorusKnotã‚’ç…§ã‚‰ã™ï¼‰
    const torusLight = new THREE.PointLight(0x00ffff, 2, 10);
    torusLight.position.set(0, 2.2, 0);
    scene.add(torusLight);

    const torusLight2 = new THREE.PointLight(0xff00ff, 1, 8);
    torusLight2.position.set(2, 3, 2);
    scene.add(torusLight2);

    const torusLight3 = new THREE.PointLight(0xffff00, 1, 8);
    torusLight3.position.set(-2, 3, -2);
    scene.add(torusLight3);

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    const particleCount = 200;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 1] = Math.random() * 10;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      velocities.push({
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02
      });
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.1,
      transparent: true,
      opacity: 0.6
    });
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    const handleKeyDown = (e) => {
      keysRef.current[e.key.toLowerCase()] = true;
      if (e.key === 'Escape') {
        setShowMessage(false);
        setShowHintModal(false);
        setShowPuzzleModal(false);
        setShowVoxelPuzzle(false);
      }
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key.toLowerCase()] = false;
    };

    const handleMouseDown = (e) => {
      isMouseDownRef.current = true;
      lastMouseRef.current = { x: e.clientX, y: e.clientY };
      e.preventDefault();
    };

    const handleMouseUp = () => {
      isMouseDownRef.current = false;
    };

    const handleMouseMove = (e) => {
      if (isMouseDownRef.current) {
        const deltaX = e.clientX - lastMouseRef.current.x;
        const deltaY = e.clientY - lastMouseRef.current.y;
        
        const sensitivity = 0.005;
        playerRef.current.rotation -= deltaX * sensitivity;
        playerRef.current.rotationX -= deltaY * sensitivity;
        playerRef.current.rotationX = Math.max(-1.5, Math.min(1.5, playerRef.current.rotationX));
        
        lastMouseRef.current = { x: e.clientX, y: e.clientY };
      }
    };

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    renderer.domElement.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('resize', handleResize);

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      const positions = particles.geometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;
        positions[i * 3 + 2] += velocities[i].z;

        if (Math.abs(positions[i * 3]) > 20) velocities[i].x *= -1;
        if (positions[i * 3 + 1] > 15 || positions[i * 3 + 1] < 0) velocities[i].y *= -1;
        if (Math.abs(positions[i * 3 + 2]) > 20) velocities[i].z *= -1;
      }
      particles.geometry.attributes.position.needsUpdate = true;

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      scene.traverse((object) => {
        if (object.userData.type === 'hint' && object.userData.baseY) {
          object.position.y = object.userData.baseY + Math.sin(time * 2 + object.userData.id) * 0.2;
          object.rotation.y = time * 0.5;
        }
        if (object.userData.isGlow) {
          const scale = 1 + Math.sin(time * 3 + object.userData.crystalId) * 0.1;
          object.scale.set(scale, scale, scale);
        }
        if (object.userData.isRune) {
          object.rotation.z = time * 0.3 * (object.userData.crystalId % 2 === 0 ? 1 : -1);
        }
        // TorusKnotã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        if (object.userData.isTorusKnot) {
          object.rotation.y = time * 0.3;
          object.rotation.x = time * 0.2;
        }
        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã®ã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (object.userData.isConsoleGlow) {
          const scale = 1 + Math.sin(time * 2) * 0.15;
          object.scale.set(scale, scale, scale);
          object.material.opacity = 0.08 + Math.sin(time * 3) * 0.05;
        }
        // ã‚ªãƒ¼ãƒ“ãƒƒãƒˆãƒªãƒ³ã‚°ã®å›è»¢
        if (object.userData.isOrbitRing) {
          const id = object.userData.id;
          if (id === 0) {
            object.rotation.x = time * 0.8;
            object.rotation.y = time * 0.3;
          } else if (id === 1) {
            object.rotation.x = Math.PI / 3;
            object.rotation.y = time * 0.6;
            object.rotation.z = time * 0.4;
          } else {
            object.rotation.x = -Math.PI / 3;
            object.rotation.y = -time * 0.5;
            object.rotation.z = time * 0.3;
          }
        }
      });

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
      const speed = 0.15;
      const player = playerRef.current;
      const keys = keysRef.current;
      const mobileKeys = window.mobileKeys || {};

      if (keys['w'] || mobileKeys.w) {
        player.x -= Math.sin(player.rotation) * speed;
        player.z -= Math.cos(player.rotation) * speed;
      }
      if (keys['s'] || mobileKeys.s) {
        player.x += Math.sin(player.rotation) * speed;
        player.z += Math.cos(player.rotation) * speed;
      }
      if (keys['a'] || mobileKeys.a) {
        player.x -= Math.cos(player.rotation) * speed;
        player.z += Math.sin(player.rotation) * speed;
      }
      if (keys['d'] || mobileKeys.d) {
        player.x += Math.cos(player.rotation) * speed;
        player.z -= Math.sin(player.rotation) * speed;
      }

      // å¢ƒç•Œåˆ¶é™
      const distFromCenter = Math.sqrt(player.x * player.x + player.z * player.z);
      if (distFromCenter > 15) {
        const angle = Math.atan2(player.z, player.x);
        player.x = Math.cos(angle) * 15;
        player.z = Math.sin(angle) * 15;
      }

      // è¿‘ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡º
      let nearestObject = null;
      let nearestDist = 3;

      hintObjectsRef.current.forEach(hint => {
        const dx = player.x - hint.position.x;
        const dz = player.z - hint.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestObject = hint;
        }
      });

      if (consoleRef.current) {
        const dx = player.x - consoleRef.current.position.x;
        const dz = player.z - consoleRef.current.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestObject = consoleRef.current;
        }
      }

      setNearbyObject(nearestObject);

      camera.position.x = player.x;
      camera.position.z = player.z;
      camera.rotation.order = 'YXZ';
      camera.rotation.y = player.rotation;
      camera.rotation.x = player.rotationX;

      // ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ãƒã‚¿ãƒ¼æ›´æ–°
      const lerpFactor = 0.15;
      const roleColors = {
        0: '#ffd700', 1: '#ff6b6b', 2: '#4ecdc4', 3: '#95e1d3', 4: '#dda0dd'
      };

      Object.entries(otherPlayersRef.current).forEach(([oderId, playerData]) => {
        // è£œé–“å‡¦ç†
        playerData.current.x += (playerData.target.x - playerData.current.x) * lerpFactor;
        playerData.current.z += (playerData.target.z - playerData.current.z) * lerpFactor;
        let rotDiff = playerData.target.rotation - playerData.current.rotation;
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerData.current.rotation += rotDiff * lerpFactor;

        let avatar = avatarMeshesRef.current[oderId];

        // ã‚¢ãƒã‚¿ãƒ¼ãŒãªã‘ã‚Œã°ä½œæˆ
        if (!avatar) {
          const color = roleColors[playerData.roleIndex] || '#ffffff';
          avatar = createMinecraftAvatar(color);
          avatar.userData.oderId = oderId;
          avatar.userData.roleName = playerData.roleName;
          scene.add(avatar);
          avatarMeshesRef.current[oderId] = avatar;

          // å½¹å‰²åãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
          if (playerData.roleName) {
            const label = createRoleLabel(playerData.roleName, color);
            avatar.add(label);
            avatar.userData.label = label;
          }
        }

        // ä½ç½®ãƒ»å‘ãæ›´æ–°
        avatar.position.x = playerData.current.x;
        avatar.position.z = playerData.current.z;
        avatar.rotation.y = playerData.current.rotation + Math.PI;

        // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        const isMoving =
          Math.abs(playerData.target.x - playerData.current.x) > 0.01 ||
          Math.abs(playerData.target.z - playerData.current.z) > 0.01;

        if (isMoving) {
          const walkCycle = time * 8;
          avatar.userData.leftArm.rotation.x = Math.sin(walkCycle) * 0.5;
          avatar.userData.rightArm.rotation.x = -Math.sin(walkCycle) * 0.5;
          avatar.userData.leftLeg.rotation.x = -Math.sin(walkCycle) * 0.4;
          avatar.userData.rightLeg.rotation.x = Math.sin(walkCycle) * 0.4;
        } else {
          avatar.userData.leftArm.rotation.x = 0;
          avatar.userData.rightArm.rotation.x = 0;
          avatar.userData.leftLeg.rotation.x = 0;
          avatar.userData.rightLeg.rotation.x = 0;
        }
      });

      // åˆ‡æ–­ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ãƒã‚¿ãƒ¼å‰Šé™¤
      Object.keys(avatarMeshesRef.current).forEach(oderId => {
        if (!otherPlayersRef.current[oderId]) {
          const avatar = avatarMeshesRef.current[oderId];
          scene.remove(avatar);
          delete avatarMeshesRef.current[oderId];
        }
      });

      renderer.render(scene, camera);
    };

    animate();

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      renderer.domElement.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('resize', handleResize);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [screen]);

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è‡ªå‹•éè¡¨ç¤º
  useEffect(() => {
    if (showMessage && screen === 'game') {
      const timer = setTimeout(() => setShowMessage(false), 30000);
      return () => clearTimeout(timer);
    }
  }, [showMessage, screen]);

  // ãƒ­ãƒ“ãƒ¼ãƒ‡ãƒ¼ã‚¿å®šæœŸæ›´æ–°
  useEffect(() => {
    if (screen === 'lobby') {
      const interval = setInterval(fetchLobbyData, 1000);
      return () => clearInterval(interval);
    }
  }, [screen, teamNumber, myPlayerId, selectedRole]);

  // ã‚²ãƒ¼ãƒ ä¸­ã®ä½ç½®é€ä¿¡ï¼ˆ500msé–“éš”ï¼‰
  useEffect(() => {
    if (screen !== 'game' || !myPlayerId) return;
    const interval = setInterval(updateMyPosition, 500);
    return () => clearInterval(interval);
  }, [screen, myPlayerId, teamNumber]);

  // ã‚²ãƒ¼ãƒ ä¸­ã®ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®å—ä¿¡ï¼ˆ1000msé–“éš”ï¼‰
  useEffect(() => {
    if (screen !== 'game' || !myPlayerId) return;
    const interval = setInterval(fetchOtherPlayers, 1000);
    return () => clearInterval(interval);
  }, [screen, myPlayerId, teamNumber]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç”»é¢
  if (screen === 'entry') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-8 rounded-lg shadow-2xl max-w-md w-full border border-cyan-500">
          <h1 className="text-4xl font-bold text-cyan-400 mb-2 text-center">ã‚µã‚¤ãƒãƒ¼ç ”ç©¶æ‰€</h1>
          <h2 className="text-2xl text-cyan-300 mb-8 text-center">è„±å‡ºã‚²ãƒ¼ãƒ </h2>
          
          <div className="mb-6">
            <div className="flex gap-2 mb-4">
              <button
                onClick={() => setJoinMode('create')}
                className={`flex-1 py-2 rounded transition ${joinMode === 'create' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                ãƒãƒ¼ãƒ ä½œæˆ
              </button>
              <button
                onClick={() => setJoinMode('join')}
                className={`flex-1 py-2 rounded transition ${joinMode === 'join' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                ãƒãƒ¼ãƒ å‚åŠ 
              </button>
            </div>

            {joinMode === 'create' ? (
              <>
                <label className="block text-cyan-300 mb-2">ãƒãƒ¼ãƒ å</label>
                <input
                  type="text"
                  value={teamName}
                  onChange={(e) => setTeamName(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleCreateTeam()}
                  className="w-full px-4 py-3 bg-gray-700 text-white rounded border border-cyan-500 focus:outline-none focus:border-cyan-400 mb-4"
                  placeholder="ãƒãƒ¼ãƒ åã‚’å…¥åŠ›"
                />
                <label className="block text-cyan-300 mb-2">ãƒãƒ¼ãƒ äººæ•°</label>
                <div className="grid grid-cols-4 gap-2 mb-4">
                  {[2, 3, 4, 5].map(num => (
                    <button
                      key={num}
                      onClick={() => setTeamSize(num)}
                      className={`py-3 rounded-lg text-xl font-bold transition ${
                        teamSize === num 
                          ? 'bg-cyan-600 text-white ring-2 ring-cyan-400' 
                          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                      }`}
                    >
                      {num}äºº
                    </button>
                  ))}
                </div>
                <button
                  onClick={handleCreateTeam}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  ãƒãƒ¼ãƒ ä½œæˆ
                </button>
              </>
            ) : (
              <>
                <label className="block text-cyan-300 mb-2">ãƒãƒ¼ãƒ ç•ªå·ï¼ˆ4æ¡ï¼‰</label>
                <input
                  type="number"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={teamNumber}
                  onChange={function(e) { setTeamNumber(e.target.value.replace(/\D/g, '').slice(0, 4)); }}
                  onKeyDown={function(e) { if (e.key === 'Enter') handleJoinTeam(); }}
                  className="w-full px-4 py-3 bg-gray-700 text-white text-center text-3xl tracking-widest font-mono rounded border border-cyan-500 focus:outline-none focus:border-cyan-400 mb-4"
                  placeholder="1234"
                  maxLength="4"
                  autoComplete="off"
                />
                <button
                  onClick={handleJoinTeam}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  ãƒãƒ¼ãƒ å‚åŠ 
                </button>
              </>
            )}
          </div>

          <div className="mt-6 text-cyan-300 text-sm space-y-1">
            <p>â€¢ åˆ¶é™æ™‚é–“: 15åˆ†</p>
            <p>â€¢ ãƒãƒ¼ãƒ äººæ•°: 2ã€œ5å</p>
            <p>â€¢ æ“ä½œ: WASDç§»å‹•ã€ãƒã‚¦ã‚¹è¦–ç‚¹</p>
          </div>
          
          {/* ç®¡ç†è€…ãƒ­ã‚°ã‚¤ãƒ³ */}
          <div className="mt-8 pt-6 border-t border-gray-700">
            <p className="text-gray-500 text-xs mb-2 text-center">ç®¡ç†è€…ç”¨</p>
            <div className="flex gap-2">
              <input
                type="password"
                value={adminPassword}
                onChange={(e) => setAdminPassword(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && enterAdminScreen()}
                className="flex-1 px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:border-gray-500 text-sm"
                placeholder="ç®¡ç†è€…ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
              />
              <button
                onClick={enterAdminScreen}
                className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-300 rounded transition text-sm"
              >
                ç®¡ç†ç”»é¢
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // ç®¡ç†ç”»é¢
  if (screen === 'admin') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-slate-900 to-gray-900 p-4 overflow-auto">
        <div className="max-w-6xl mx-auto">
          {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-3xl font-bold text-cyan-400">ğŸ® ç®¡ç†ç”»é¢</h1>
            <div className="flex gap-4">
              <button
                onClick={fetchAllTeams}
                className="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded transition"
              >
                ğŸ”„ æ›´æ–°
              </button>
              <button
                onClick={resetAllTeams}
                className="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded transition"
              >
                ğŸ—‘ï¸ å…¨å‰Šé™¤
              </button>
              <button
                onClick={exitAdminScreen}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded transition"
              >
                â† æˆ»ã‚‹
              </button>
            </div>
          </div>
          
          {/* çµ±è¨ˆã‚µãƒãƒªãƒ¼ */}
          <div className="grid grid-cols-4 gap-4 mb-6">
            <div className="bg-gray-800 p-4 rounded-lg border border-cyan-500">
              <p className="text-gray-400 text-sm">ç·ãƒãƒ¼ãƒ æ•°</p>
              <p className="text-3xl font-bold text-white">{allTeams.length}</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-green-500">
              <p className="text-gray-400 text-sm">ã‚¯ãƒªã‚¢æ¸ˆã¿</p>
              <p className="text-3xl font-bold text-green-400">
                {allTeams.filter(t => t.completed).length}
              </p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-yellow-500">
              <p className="text-gray-400 text-sm">ãƒ—ãƒ¬ã‚¤ä¸­</p>
              <p className="text-3xl font-bold text-yellow-400">
                {allTeams.filter(t => t.startTime && !t.completed && getTeamTimeLeft(t) > 0).length}
              </p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-red-500">
              <p className="text-gray-400 text-sm">æ™‚é–“åˆ‡ã‚Œ</p>
              <p className="text-3xl font-bold text-red-400">
                {allTeams.filter(t => t.startTime && !t.completed && getTeamTimeLeft(t) <= 0).length}
              </p>
            </div>
          </div>
          
          {/* ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆã‚¯ãƒªã‚¢æ¸ˆã¿ãƒãƒ¼ãƒ ï¼‰ */}
          {allTeams.filter(t => t.completed).length > 0 && (
            <div className="mb-6">
              <h2 className="text-xl font-bold text-cyan-400 mb-3">ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
              <div className="bg-gray-800 rounded-lg border border-cyan-500 overflow-hidden">
                <table className="w-full">
                  <thead className="bg-gray-700">
                    <tr>
                      <th className="px-4 py-3 text-left text-cyan-300">é †ä½</th>
                      <th className="px-4 py-3 text-left text-cyan-300">ãƒãƒ¼ãƒ å</th>
                      <th className="px-4 py-3 text-left text-cyan-300">ã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ </th>
                      <th className="px-4 py-3 text-left text-cyan-300">ãƒ¡ãƒ³ãƒãƒ¼æ•°</th>
                    </tr>
                  </thead>
                  <tbody>
                    {allTeams.filter(t => t.completed).map((team, idx) => (
                      <tr key={team.number} className={idx % 2 === 0 ? 'bg-gray-800' : 'bg-gray-750'}>
                        <td className="px-4 py-3">
                          <span className={`text-2xl ${idx === 0 ? 'text-yellow-400' : idx === 1 ? 'text-gray-300' : idx === 2 ? 'text-amber-600' : 'text-gray-500'}`}>
                            {idx === 0 ? 'ğŸ¥‡' : idx === 1 ? 'ğŸ¥ˆ' : idx === 2 ? 'ğŸ¥‰' : `${idx + 1}ä½`}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-white font-bold">{team.name}</td>
                        <td className="px-4 py-3 text-green-400 font-mono text-lg">
                          {formatTime(team.completionTime || 0)}
                        </td>
                        <td className="px-4 py-3 text-gray-300">{team.members?.length || 0}å</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
          
          {/* å…¨ãƒãƒ¼ãƒ ä¸€è¦§ */}
          <h2 className="text-xl font-bold text-cyan-400 mb-3">ğŸ“‹ å…¨ãƒãƒ¼ãƒ çŠ¶æ³</h2>
          <div className="grid gap-4">
            {allTeams.length === 0 ? (
              <div className="bg-gray-800 p-8 rounded-lg border border-gray-700 text-center">
                <p className="text-gray-400">ã¾ã ãƒãƒ¼ãƒ ãŒä½œæˆã•ã‚Œã¦ã„ã¾ã›ã‚“</p>
              </div>
            ) : (
              allTeams.map(team => {
                const timeRemaining = getTeamTimeLeft(team);
                const isPlaying = team.startTime && !team.completed && timeRemaining > 0;
                const isTimeout = team.startTime && !team.completed && timeRemaining <= 0;
                
                return (
                  <div
                    key={team.number}
                    className={`bg-gray-800 p-4 rounded-lg border ${
                      team.completed ? 'border-green-500' : isTimeout ? 'border-red-500' : isPlaying ? 'border-yellow-500' : 'border-gray-600'
                    }`}
                  >
                    <div className="flex justify-between items-start">
                      <div>
                        <div className="flex items-center gap-3">
                          <h3 className="text-lg font-bold text-white">{team.name}</h3>
                          <span className="text-gray-500 text-sm">#{team.number}</span>
                          {team.completed && (
                            <span className="px-2 py-1 bg-green-500 bg-opacity-20 text-green-400 text-xs rounded">
                              âœ“ ã‚¯ãƒªã‚¢
                            </span>
                          )}
                          {isTimeout && (
                            <span className="px-2 py-1 bg-red-500 bg-opacity-20 text-red-400 text-xs rounded">
                              æ™‚é–“åˆ‡ã‚Œ
                            </span>
                          )}
                          {isPlaying && (
                            <span className="px-2 py-1 bg-yellow-500 bg-opacity-20 text-yellow-400 text-xs rounded animate-pulse">
                              ãƒ—ãƒ¬ã‚¤ä¸­
                            </span>
                          )}
                          {!team.startTime && (
                            <span className="px-2 py-1 bg-gray-500 bg-opacity-20 text-gray-400 text-xs rounded">
                              å¾…æ©Ÿä¸­
                            </span>
                          )}
                        </div>
                        <p className="text-gray-400 text-sm mt-1">
                          ãƒ¡ãƒ³ãƒãƒ¼: {team.members?.length || 0}å
                        </p>
                      </div>
                      
                      <div className="text-right">
                        {team.completed ? (
                          <div>
                            <p className="text-gray-400 text-xs">ã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ </p>
                            <p className="text-2xl font-bold text-green-400 font-mono">
                              {formatTime(team.completionTime || 0)}
                            </p>
                          </div>
                        ) : team.startTime ? (
                          <div>
                            <p className="text-gray-400 text-xs">æ®‹ã‚Šæ™‚é–“</p>
                            <p className={`text-2xl font-bold font-mono ${timeRemaining < 60 ? 'text-red-400' : 'text-cyan-400'}`}>
                              {formatTime(timeRemaining)}
                            </p>
                          </div>
                        ) : null}
                      </div>
                    </div>
                    
                    {/* é€²æ—ãƒãƒ¼ */}
                    <div className="mt-3">
                      <div className="flex justify-between text-xs text-gray-400 mb-1">
                        <span>ãƒ’ãƒ³ãƒˆé€²æ—</span>
                        <span>{team.hintsFound?.length || 0} / {getTeamSettings(team.maxMembers || 5).hintsRequired}</span>
                      </div>
                      <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-gradient-to-r from-cyan-500 to-green-500 transition-all duration-500"
                          style={{ width: `${((team.hintsFound?.length || 0) / getTeamSettings(team.maxMembers || 5).hintsRequired) * 100}%` }}
                        />
                      </div>
                      
                      {/* ãƒ’ãƒ³ãƒˆè©³ç´° */}
                      <div className="flex gap-2 mt-2">
                        {[0, 1, 2, 3, 4].map(idx => (
                          <div
                            key={idx}
                            className={`w-8 h-8 rounded flex items-center justify-center text-xs ${
                              team.hintsFound?.includes(idx)
                                ? 'bg-green-500 bg-opacity-30 text-green-400 border border-green-500'
                                : 'bg-gray-700 text-gray-500 border border-gray-600'
                            }`}
                            title={roles[idx]?.name}
                          >
                            {team.hintsFound?.includes(idx) ? 'âœ“' : idx + 1}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })
            )}
          </div>
          
          {/* ãƒ•ãƒƒã‚¿ãƒ¼æƒ…å ± */}
          <div className="mt-6 text-center text-gray-500 text-sm">
            <p>5ç§’ã”ã¨ã«è‡ªå‹•æ›´æ–° | ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰: admin123</p>
          </div>
        </div>
      </div>
    );
  }

  // å¾…æ©Ÿå®¤ï¼ˆãƒãƒ¼ãƒ ç•ªå·å…±æœ‰ç”¨ï¼‰
  if (screen === 'waiting') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-8 rounded-lg shadow-2xl max-w-md w-full border border-cyan-500">
          <h1 className="text-3xl font-bold text-cyan-400 mb-6 text-center">å¾…æ©Ÿå®¤</h1>
          
          <div className="bg-gray-900 p-6 rounded-lg mb-6 border border-cyan-500">
            <div className="text-center mb-4">
              <p className="text-cyan-300 mb-2">ãƒãƒ¼ãƒ å</p>
              <p className="text-2xl font-bold text-white">{teamName}</p>
            </div>
            <div className="text-center mb-4">
              <p className="text-cyan-300 mb-1">ãƒãƒ¼ãƒ äººæ•°</p>
              <p className="text-xl font-bold text-cyan-400">{teamSize}äºº</p>
            </div>
            <div className="text-center">
              <p className="text-cyan-300 mb-3">ãƒãƒ¼ãƒ ç•ªå·ï¼ˆã“ã‚Œã‚’ä¼ãˆã¦ã­ï¼ï¼‰</p>
              <p className="text-7xl font-bold text-cyan-400 tracking-widest font-mono">{teamNumber}</p>
            </div>
          </div>

          <button
            onClick={enterLobby}
            className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition mb-4"
          >
            ãƒ­ãƒ“ãƒ¼ã«å…¥ã‚‹ â†’
          </button>

          <button
            onClick={() => setScreen('entry')}
            className="w-full bg-gray-700 hover:bg-gray-600 text-white py-2 rounded transition"
          >
            â† æˆ»ã‚‹
          </button>
        </div>
      </div>
    );
  }

  // ãƒ­ãƒ“ãƒ¼ç”»é¢ï¼ˆå½¹å‰²é¸æŠï¼‰
  if (screen === 'lobby') {
    const memberCount = lobbyData?.members?.length || 0;
    const maxMembers = lobbyData?.maxMembers || teamSize;
    const availableRoles = getRolesForTeamSize(maxMembers);
    const allMembersJoined = memberCount >= maxMembers;
    
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-6 rounded-lg shadow-2xl max-w-2xl w-full border border-cyan-500">
          {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
          <div className="flex justify-between items-center mb-4">
            <div>
              <h1 className="text-2xl font-bold text-cyan-400">{teamName}</h1>
              <p className="text-gray-400 text-sm">#{teamNumber}</p>
            </div>
            <div className="text-right">
              <p className="text-gray-400 text-sm">å‚åŠ è€…</p>
              <p className={`text-2xl font-bold ${allMembersJoined ? 'text-green-400' : 'text-white'}`}>
                {memberCount}/{maxMembers}å
              </p>
            </div>
          </div>
          
          {/* ãƒ¡ãƒ³ãƒãƒ¼å¾…ã¡ or ã‚¿ã‚¤ãƒãƒ¼ */}
          {!allMembersJoined ? (
            <div className="text-center p-6 bg-gray-900 rounded-lg mb-6 border border-yellow-500">
              <p className="text-yellow-400 text-xl mb-2">ãƒ¡ãƒ³ãƒãƒ¼å¾…æ©Ÿä¸­...</p>
              <p className="text-gray-400">å…¨å“¡æƒã£ãŸã‚‰å½¹å‰²ã‚’é¸ã¹ã¾ã™</p>
            </div>
          ) : (
            <div className={`text-center p-4 rounded-lg mb-6 ${roleSelectTimer <= 10 ? 'bg-red-900 border-red-500' : 'bg-gray-900 border-cyan-500'} border`}>
              <p className="text-gray-400 text-sm mb-1">å½¹å‰²æ±ºã‚ã‚¿ã‚¤ãƒ </p>
              <p className={`text-4xl font-bold font-mono ${roleSelectTimer <= 10 ? 'text-red-400 animate-pulse' : 'text-cyan-400'}`}>
                {roleSelectTimer}ç§’
              </p>
              <p className="text-gray-500 text-xs mt-1">
                æ™‚é–“åˆ‡ã‚Œã§æœªé¸æŠã®äººã¯è‡ªå‹•å‰²ã‚Šå½“ã¦
              </p>
            </div>
          )}
          
          {/* å½¹å‰²é¸æŠã‚«ãƒ¼ãƒ‰ */}
          <div className="mb-6">
            <p className="text-cyan-300 mb-3 text-center">
              {allMembersJoined ? 'ğŸ‘¥ ãƒãƒ¼ãƒ ã§ç›¸è«‡ã—ã¦å½¹å‰²ã‚’æ±ºã‚ã¦ãã ã•ã„' : 'ğŸ‘¥ ãƒ¡ãƒ³ãƒãƒ¼ãŒæƒã†ã¾ã§ãŠå¾…ã¡ãã ã•ã„'}
            </p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {availableRoles.map((r, idx) => {
                const takenBy = lobbyData?.members?.find(m => m.roleIndex === idx);
                const isMySelection = selectedRole === idx;
                const isTaken = takenBy && !isMySelection;
                
                return (
                  <div
                    key={r.id}
                    className={`p-4 rounded-lg border-2 transition-all ${
                      isMySelection 
                        ? 'border-green-500 bg-green-900 bg-opacity-30' 
                        : isTaken 
                          ? 'border-gray-600 bg-gray-800 opacity-60'
                          : 'border-gray-600 bg-gray-800 hover:border-cyan-400'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <div 
                        className="w-12 h-12 rounded-full flex items-center justify-center text-2xl"
                        style={{ backgroundColor: r.color + '40', border: `2px solid ${r.color}` }}
                      >
                        {r.icon}
                      </div>
                      <div className="flex-1">
                        <h3 className="font-bold text-white">{r.name}</h3>
                        <p className="text-gray-400 text-xs">Role {idx + 1}</p>
                      </div>
                      
                      {isMySelection ? (
                        <span className="px-3 py-1 bg-green-600 text-white text-sm rounded">
                          âœ“ é¸æŠä¸­
                        </span>
                      ) : isTaken ? (
                        <span className="px-3 py-1 bg-gray-600 text-gray-300 text-sm rounded">
                          é¸æŠæ¸ˆã¿
                        </span>
                      ) : !allMembersJoined ? (
                        <span className="px-3 py-1 bg-gray-700 text-gray-500 text-sm rounded">
                          å¾…æ©Ÿä¸­
                        </span>
                      ) : selectedRole === null ? (
                        <button
                          onClick={() => selectRole(idx)}
                          className="px-3 py-1 bg-cyan-600 hover:bg-cyan-500 text-white text-sm rounded transition"
                        >
                          é¸æŠ
                        </button>
                      ) : (
                        <span className="px-3 py-1 bg-gray-700 text-gray-400 text-sm rounded">
                          ---
                        </span>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* ãƒ¡ãƒ³ãƒãƒ¼çŠ¶æ³ */}
          <div className="bg-gray-900 p-4 rounded-lg mb-4">
            <p className="text-gray-400 text-sm mb-2">ãƒ¡ãƒ³ãƒãƒ¼çŠ¶æ³</p>
            <div className="flex flex-wrap gap-2">
              {lobbyData?.members?.map((member, idx) => {
                const memberRoles = getRolesForTeamSize(maxMembers);
                return (
                  <div 
                    key={member.oderId || idx}
                    className={`px-3 py-1 rounded-full text-sm ${
                      member.oderId === myPlayerId 
                        ? 'bg-cyan-600 text-white' 
                        : member.roleIndex !== undefined
                          ? 'bg-green-600 bg-opacity-50 text-green-300'
                          : 'bg-gray-700 text-gray-400'
                    }`}
                  >
                    {member.oderId === myPlayerId ? 'è‡ªåˆ†' : `Player ${idx + 1}`}
                    {member.roleIndex !== undefined && ` (${memberRoles[member.roleIndex]?.icon})`}
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */}
          <div className="flex gap-3">
            <button
              onClick={exitLobby}
              className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition"
            >
              â† æˆ»ã‚‹
            </button>
            <button
              onClick={handleStartGame}
              disabled={selectedRole === null || !allMembersJoined}
              className={`flex-1 font-bold py-3 rounded transition ${
                selectedRole !== null && allMembersJoined
                  ? 'bg-green-600 hover:bg-green-500 text-white'
                  : 'bg-gray-600 text-gray-400 cursor-not-allowed'
              }`}
            >
              {!allMembersJoined ? 'ãƒ¡ãƒ³ãƒãƒ¼å¾…ã¡...' : selectedRole !== null ? 'ã‚²ãƒ¼ãƒ é–‹å§‹ï¼' : 'å½¹å‰²ã‚’é¸ã‚“ã§ãã ã•ã„'}
            </button>
          </div>
          
          {/* ãƒ†ã‚¹ãƒˆç”¨ãƒœã‚¿ãƒ³ */}
          {!allMembersJoined && (
            <button
              onClick={forceFullTeam}
              className="w-full mt-3 bg-yellow-600 hover:bg-yellow-500 text-white py-2 rounded text-sm"
            >
              ğŸ§ª ãƒ†ã‚¹ãƒˆï¼šãƒ€ãƒŸãƒ¼ãƒ¡ãƒ³ãƒãƒ¼è¿½åŠ ï¼ˆ1äººã§ãƒ†ã‚¹ãƒˆï¼‰
            </button>
          )}
        </div>
      </div>
    );
  }

  // ã‚²ãƒ¼ãƒ ç”»é¢
  if (screen === 'game') {
    return (
      <div className="relative w-full h-screen overflow-hidden">
        <div ref={mountRef} className="w-full h-full" />
        
        {/* ã‚¿ã‚¤ãƒãƒ¼ */}
        <div className="absolute top-4 right-4 bg-black bg-opacity-70 px-6 py-3 rounded border border-cyan-500">
          <div className={`text-2xl font-bold ${timeLeft < 60 ? 'text-red-400 animate-pulse' : 'text-cyan-400'}`}>
            {formatTime(timeLeft)}
          </div>
        </div>

        {/* ãƒãƒ¼ãƒ æƒ…å ± */}
        <div className="absolute top-4 left-4 bg-black bg-opacity-70 px-6 py-3 rounded border border-cyan-500">
          <div className="text-cyan-400 font-bold">{teamName}</div>
          <div className="text-cyan-300 text-sm">#{teamNumber}</div>
          {assignedRoles.length > 0 && (
            <div className="mt-2 text-sm">
              {assignedRoles.map((r, i) => (
                <span key={r.id} className="inline-block px-2 py-1 rounded mr-1 mb-1" style={{ backgroundColor: r.color + '40', color: r.color }}>
                  {r.name}
                </span>
              ))}
            </div>
          )}
        </div>

        {/* ãƒ’ãƒ³ãƒˆé€²æ— */}
        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 px-4 py-2 rounded border border-cyan-500">
          <div className="text-cyan-300 text-sm">ãƒ’ãƒ³ãƒˆ: {hintsFound.length} / {getTeamSettings(teamSize).hintsRequired}</div>
        </div>

        {/* ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³UI */}
        {nearbyObject && !showHintModal && !showPuzzleModal && (
          <div className="absolute bottom-24 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 px-6 py-3 rounded border-2 border-cyan-400 animate-pulse">
            <p className="text-cyan-400 text-lg font-bold text-center">
              {nearbyObject.type === 'hint' ? (
                <>
                  <span className="text-2xl">E</span> ã‚’æŠ¼ã—ã¦èª¿ã¹ã‚‹
                  {hintsFound.includes(nearbyObject.id) && <span className="ml-2 text-green-400">ï¼ˆå–å¾—æ¸ˆã¿ï¼‰</span>}
                </>
              ) : (
                <>
                  <span className="text-2xl">E</span> ã‚’æŠ¼ã—ã¦ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’æ“ä½œ
                </>
              )}
            </p>
          </div>
        )}

        {/* å½¹å‰²ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆé›»å…‰æ²ç¤ºæ¿ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰ */}
        {showMessage && role && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-50">
            <div className="max-w-3xl w-full mx-4">
              <div className="bg-gray-900 border-2 rounded-lg p-8 shadow-2xl" style={{ borderColor: role.color }}>
                <div className="flex items-center justify-center gap-3 mb-2">
                  <span className="text-4xl">{role.icon}</span>
                  <h2 className="text-3xl font-bold" style={{ color: role.color }}>
                    {role.name}
                  </h2>
                </div>
                <p className="text-gray-400 text-center mb-6">ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ - ãƒ¡ãƒ¢ã‚’å–ã£ã¦ãã ã•ã„ï¼</p>
                
                {/* é›»å…‰æ²ç¤ºæ¿ã‚¨ãƒªã‚¢ */}
                <div className="bg-black rounded-lg p-4 mb-6 overflow-hidden border border-gray-700">
                  <style>
                    {`
                      @keyframes scrollText {
                        0% { transform: translateX(100%); }
                        100% { transform: translateX(-100%); }
                      }
                    `}
                  </style>
                  <div className="space-y-4">
                    {getSecretMessage(teamSize, role.id).map((line, idx) => (
                      <div key={idx} className="relative h-8 overflow-hidden border-b border-gray-800">
                        <div 
                          style={{ 
                            color: role.color,
                            textShadow: `0 0 10px ${role.color}`,
                            animation: `scrollText 8s linear infinite`,
                            animationDelay: `${idx * 0.5}s`,
                            whiteSpace: 'nowrap',
                            position: 'absolute',
                            fontSize: '1.25rem',
                            fontFamily: 'monospace',
                            fontWeight: 'bold'
                          }}
                        >
                          â— {line} â— {line} â— {line} â—
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                
                <p className="text-gray-500 text-sm text-center mb-4">â€» ä¸€äººã§ã¯çµ¶å¯¾ã«è§£ã‘ã¾ã›ã‚“ã€‚ä»²é–“ã¨æƒ…å ±ã‚’å…±æœ‰ã—ã‚ˆã†ï¼</p>
                
                <button
                  onClick={() => setShowMessage(false)}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  3Dç©ºé–“ã«å…¥ã‚‹ â†’
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ãƒ’ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ« */}
        {showHintModal && currentHint && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50">
            <div className="max-w-lg w-full mx-4">
              <div className="bg-gray-900 border-2 rounded-lg p-6 shadow-2xl" style={{ borderColor: currentHint.color }}>
                <h2 className="text-2xl font-bold mb-4 text-center" style={{ color: currentHint.color }}>
                  {currentHint.title}
                </h2>
                <div className="bg-black p-4 rounded mb-4">
                  <pre className="text-lg font-mono whitespace-pre-wrap" style={{ color: currentHint.color }}>
                    {currentHint.message}
                  </pre>
                </div>
                <button
                  onClick={() => setShowHintModal(false)}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  é–‰ã˜ã‚‹ (ESC)
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ãƒ‘ã‚ºãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« */}
        {showPuzzleModal && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50">
            <div className="max-w-2xl w-full mx-4">
              <div className="bg-gray-900 border-2 border-cyan-500 rounded-lg p-6 shadow-2xl">
                <h2 className="text-2xl font-bold mb-4 text-center text-cyan-400">
                  ğŸ” ä¸­å¤®ã‚³ãƒ³ã‚½ãƒ¼ãƒ« - æœ€çµ‚èªè¨¼
                </h2>
                
                <div className="bg-gray-800 p-4 rounded mb-4">
                  <p className="text-gray-300 text-center mb-2">
                    {role?.id === 'leader'
                      ? 'ğŸ‘‘ ãƒªãƒ¼ãƒ€ãƒ¼ã¯ãƒãƒ¼ãƒ ãŒè§£é™¤ã—ãŸå…¨ã¦ã®ãƒ’ãƒ³ãƒˆã‚’ç¢ºèªã§ãã¾ã™'
                      : 'å…¨ã¦ã®ãƒ’ãƒ³ãƒˆã‚’é›†ã‚ã¦ã‹ã‚‰æœ€çµ‚ãƒ‘ã‚ºãƒ«ã«æŒ‘æˆ¦ã—ã¦ãã ã•ã„'}
                  </p>
                  <div className="grid grid-cols-1 gap-2 mb-4">
                    {[
                      { name: 'ãƒªãƒ¼ãƒ€ãƒ¼', color: '#ffd700', id: 'leader' },
                      { name: 'è§£èª­å“¡', color: '#ff6b6b', id: 'decoder' },
                      { name: 'èª¿æŸ»å“¡', color: '#4ecdc4', id: 'investigator' },
                      { name: 'åˆ†æå“¡', color: '#95e1d3', id: 'analyst' },
                      { name: 'é€šä¿¡å“¡', color: '#dda0dd', id: 'communicator' }
                    ].map(function(info, idx) {
                      const isFound = hintsFound.includes(idx);
                      const myPerms = role ? getHintPermissions(teamSize, role.id) : [];
                      const canView = role?.id === 'leader' || myPerms.includes(idx);
                      const hintContent = (() => {
                        const contents = {
                          2: { 0: ['â–²ã¯1ç•ªç›®'], 1: ['â˜…ã¯3ç•ªç›®'], 2: ['â—ã¯â– ã‚ˆã‚Šå¾Œã‚'], 3: ['æ•°åˆ—ï¼š3, 4, 5, ?, ?', 'â– ã¯2ç•ªç›®'], 4: ['â—†ã¯æœ€å¾Œ', '?ã¯0ã¨4'] },
                          3: { 0: ['1ç•ªç›®ã¯3è§’ã®å½¢'], 1: ['4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹'], 2: ['æ•°åˆ—ï¼š3, 4, 5, 0, 4'], 3: ['ã“ã®æ•°åˆ—ãŒé †ç•ªã‚’æ±ºã‚ã‚‹'], 4: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'] },
                          4: { 0: ['ç­”ãˆã¯5ã¤ã®å½¢ã®åˆ—'], 1: ['è§’ã®æ•°ã§é †ç•ªãŒæ±ºã¾ã‚‹'], 2: ['3ç•ªç›®ã¯5è§’'], 3: ['é’=â–² ç·‘=â–  é»„=â˜…', 'èµ¤=â— ç´«=â—†'], 4: ['æ•°åˆ—å®Œæˆï¼š3,4,5,0,4', '4ç•ªç›®ã¯0'] },
                          5: { 0: ['å…¨å“¡ã®æƒ…å ±ã‚’çµ±åˆã›ã‚ˆ'], 1: ['è§’ã®æ•°ãŒé †ç•ªã®æ³•å‰‡'], 2: ['é’=â–² ç·‘=â– ', 'é»„=â˜… èµ¤=â— ç´«=â—†'], 3: ['æ•°åˆ—ï¼š3,4,5,0,4'], 4: ['4è§’ã®å½¢ã¯2ã¤ã‚ã‚‹', 'â– ãŒå…ˆã€â—†ãŒå¾Œ'] },
                        };
                        return contents[teamSize]?.[idx] || ['ãƒ’ãƒ³ãƒˆãªã—'];
                      })();

                      return (
                        <div
                          key={idx}
                          className={'p-3 rounded border-2 transition-all ' + (
                            isFound ? 'bg-gray-700' : 'bg-gray-800 opacity-50'
                          )}
                          style={{ borderColor: isFound ? info.color : '#4b5563' }}
                        >
                          <div className="flex items-center gap-2 mb-1">
                            <div
                              className="w-6 h-6 rounded-full flex items-center justify-center text-xs"
                              style={{ backgroundColor: info.color + '33', color: info.color }}
                            >
                              {isFound ? 'âœ“' : '?'}
                            </div>
                            <span style={{ color: info.color }} className="font-bold text-sm">{info.name}</span>
                            {!isFound && <span className="text-gray-500 text-xs ml-auto">æœªå–å¾—</span>}
                          </div>
                          {isFound && (
                            <div className="text-sm mt-2 pl-8">
                              {canView ? (
                                <div className="text-white">
                                  {hintContent.map((line, i) => (
                                    <p key={i} className="text-cyan-300">{line}</p>
                                  ))}
                                </div>
                              ) : (
                                <p className="text-gray-400 italic">ğŸ”’ {info.name}ã®ã¿é–²è¦§å¯</p>
                              )}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  <p className="text-cyan-400 text-center text-lg font-bold">
                    åé›†æ¸ˆã¿: {hintsFound.length} / {getTeamSettings(teamSize).hintsRequired}
                  </p>
                </div>

                {puzzleError && (
                  <p className="text-yellow-400 text-center mb-4">{puzzleError}</p>
                )}

                <div className="flex gap-4">
                  <button
                    onClick={() => {
                      setShowPuzzleModal(false);
                      setPuzzleError('');
                    }}
                    className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition"
                  >
                    æˆ»ã‚‹ (ESC)
                  </button>
                  <button
                    onClick={startFinalPuzzle}
                    disabled={hintsFound.length < getTeamSettings(teamSize).hintsRequired}
                    className={`flex-1 font-bold py-3 rounded transition ${
                      hintsFound.length >= getTeamSettings(teamSize).hintsRequired
                        ? 'bg-cyan-600 hover:bg-cyan-500 text-white'
                        : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                    }`}
                  >
                    æœ€çµ‚ãƒ‘ã‚ºãƒ«ã«æŒ‘æˆ¦
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* æœ€çµ‚ãƒ‘ã‚ºãƒ«å…¥åŠ›ç”»é¢ */}
        {showFinalInputModal && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-50">
            <div className="max-w-lg w-full mx-4">
              <div className="bg-gray-900 border-2 border-green-500 rounded-lg p-6 shadow-2xl">
                <h2 className="text-2xl font-bold mb-4 text-center text-green-400">
                  ğŸ”“ æœ€çµ‚èªè¨¼ - å½¢ã‚’å…¥åŠ›
                </h2>

                <p className="text-gray-300 text-center mb-4">
                  ãƒãƒ¼ãƒ ã§é›†ã‚ãŸãƒ’ãƒ³ãƒˆã‚’å…ƒã«ã€æ­£ã—ã„é †ç•ªã§å½¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
                </p>

                <div className="bg-gray-800 p-4 rounded mb-4">
                  <p className="text-gray-400 text-sm mb-2 text-center">ä½¿ç”¨ã§ãã‚‹å½¢: â–² â–  â˜… â— â—†</p>
                  <div className="flex justify-center gap-2">
                    {puzzleInput.map((val, idx) => (
                      <input
                        key={idx}
                        type="text"
                        value={val}
                        onChange={(e) => {
                          const newInput = [...puzzleInput];
                          newInput[idx] = e.target.value;
                          setPuzzleInput(newInput);
                        }}
                        className="w-12 h-12 text-center text-2xl bg-gray-700 border-2 border-cyan-500 rounded text-white focus:border-green-400 focus:outline-none"
                        maxLength={1}
                        placeholder={(idx + 1).toString()}
                      />
                    ))}
                  </div>
                </div>

                <div className="bg-gray-800 p-3 rounded mb-4">
                  <p className="text-xs text-gray-400 text-center">
                    ãƒ’ãƒ³ãƒˆ: å„å½¢ã‚’å¯¾å¿œã™ã‚‹è¨˜å·ã§å…¥åŠ›<br/>
                    ä¸‰è§’=â–² å››è§’=â–  æ˜Ÿ=â˜… ä¸¸=â— ã²ã—å½¢=â—†
                  </p>
                </div>

                {puzzleError && (
                  <p className="text-red-400 text-center mb-4">{puzzleError}</p>
                )}

                <div className="flex gap-4">
                  <button
                    onClick={() => {
                      setShowFinalInputModal(false);
                      setPuzzleError('');
                    }}
                    className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition"
                  >
                    ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                  </button>
                  <button
                    onClick={checkPuzzleAnswer}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded transition"
                  >
                    èªè¨¼ã™ã‚‹
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* åå°„ç¥çµŒã‚²ãƒ¼ãƒ ã¯DOMç›´æ¥æ“ä½œã§è¡¨ç¤ºï¼ˆstartReflexGameé–¢æ•°ï¼‰ */}

        {/* æ“ä½œèª¬æ˜ï¼ˆPCå‘ã‘ï¼‰ */}
        <div className="absolute bottom-4 left-4 bg-black bg-opacity-70 px-4 py-2 rounded text-cyan-300 text-sm hidden md:block">
          <p>WASD: ç§»å‹• | ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°: è¦–ç‚¹å›è»¢ | E: èª¿ã¹ã‚‹</p>
        </div>

        {/* ã‚¹ãƒãƒ›ç”¨æ“ä½œãƒœã‚¿ãƒ³ */}
        <div className="absolute bottom-4 left-4 md:hidden flex flex-col gap-2">
          <div className="flex justify-center">
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.w = true; }}
              onTouchEnd={function() { window.mobileKeys.w = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >â†‘</button>
          </div>
          <div className="flex gap-2">
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.a = true; }}
              onTouchEnd={function() { window.mobileKeys.a = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >â†</button>
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.s = true; }}
              onTouchEnd={function() { window.mobileKeys.s = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >â†“</button>
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.d = true; }}
              onTouchEnd={function() { window.mobileKeys.d = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >â†’</button>
          </div>
        </div>

        {/* ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ï¼ˆè¿‘ãã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹æ™‚è¡¨ç¤ºï¼‰ */}
        {nearbyObject && (
          <button
            onClick={handleInteraction}
            className="absolute bottom-4 right-4 bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-4 px-8 rounded-lg text-xl shadow-lg animate-pulse"
          >
            ğŸ” èª¿ã¹ã‚‹ (E)
          </button>
        )}

        <style jsx>{`
          @keyframes marquee {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
          }
          .animate-marquee {
            animation: marquee 30s linear infinite;
          }
        `}</style>
      </div>
    );
  }

  // å®Œäº†ç”»é¢
  if (screen === 'complete') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4 overflow-auto">
        <div className="bg-gray-800 bg-opacity-95 p-8 rounded-2xl shadow-2xl max-w-lg w-full border-2 border-cyan-500 text-center">
          {gameCompleted ? (
            <>
              <div className="text-6xl mb-4">ğŸ‰</div>
              <h1 className="text-5xl font-bold text-green-400 mb-4">è„±å‡ºæˆåŠŸï¼</h1>
              <p className="text-cyan-300 text-xl mb-6">ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼</p>

              <div className="bg-gray-900 rounded-xl p-6 mb-6">
                <p className="text-gray-400 text-sm mb-2">ãƒãƒ¼ãƒ å</p>
                <p className="text-white text-2xl font-bold mb-4">{teamName}</p>

                <p className="text-gray-400 text-sm mb-2">ãƒãƒ¼ãƒ ç•ªå·</p>
                <p className="text-cyan-400 text-xl font-mono mb-4">{teamNumber}</p>

                <div className="border-t border-gray-700 pt-4 mt-4">
                  <p className="text-gray-400 text-sm mb-2">ã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ </p>
                  <p className="text-4xl font-bold text-green-400 font-mono">
                    {formatTime(completionTime || 0)}
                  </p>
                </div>
              </div>

              <p className="text-gray-400 text-sm mb-6">
                ãƒãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§è¦‹äº‹ã«ç ”ç©¶æ‰€ã‹ã‚‰ã®è„±å‡ºã«æˆåŠŸã—ã¾ã—ãŸï¼
              </p>
            </>
          ) : (
            <>
              <div className="text-6xl mb-4">â°</div>
              <h1 className="text-4xl font-bold text-red-400 mb-4">æ™‚é–“åˆ‡ã‚Œ</h1>
              <p className="text-cyan-300 text-xl mb-6">ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼</p>

              <div className="bg-gray-900 rounded-xl p-6 mb-6">
                <p className="text-gray-400 text-sm mb-2">ãƒãƒ¼ãƒ å</p>
                <p className="text-white text-2xl font-bold mb-4">{teamName}</p>

                <p className="text-gray-400 text-sm mb-2">ãƒãƒ¼ãƒ ç•ªå·</p>
                <p className="text-cyan-400 text-xl font-mono mb-4">{teamNumber}</p>

                <div className="border-t border-gray-700 pt-4 mt-4">
                  <p className="text-gray-400 text-sm mb-2">åé›†ã—ãŸãƒ’ãƒ³ãƒˆ</p>
                  <p className="text-2xl font-bold text-yellow-400">
                    {hintsFound.length} / {getTeamSettings(teamSize).hintsRequired}
                  </p>
                </div>
              </div>

              <p className="text-gray-400 text-sm mb-6">
                æƒœã—ã„ï¼ã‚‚ã†å°‘ã—ã§è„±å‡ºã§ããŸã‹ã‚‚...
              </p>
            </>
          )}

          <button
            onClick={() => window.location.reload()}
            className="w-full bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-bold py-4 rounded-xl transition text-lg shadow-lg"
          >
            ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
          </button>
        </div>
      </div>
    );
  }

  return null;
};


    ReactDOM.render(<CyberEscapeGame />, document.getElementById('root'));
  </script>
</body>
</html>
