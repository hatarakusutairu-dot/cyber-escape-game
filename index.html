<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>サイバー研究所 脱出ゲーム v2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    @keyframes marquee {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-200%); }
    }
    .animate-marquee {
      animation: marquee 30s linear infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // チームサイズ別設定（e-スポーツコース高校生向け調整）
    const TEAM_SETTINGS = {
      2: { timeLimit: 720, hintsRequired: 5, difficulty: 4 },  // 12分、5ヒント
      3: { timeLimit: 780, hintsRequired: 5, difficulty: 4 },  // 13分、5ヒント
      4: { timeLimit: 840, hintsRequired: 5, difficulty: 4 },  // 14分、5ヒント
      5: { timeLimit: 900, hintsRequired: 5, difficulty: 4 },  // 15分、5ヒント
    };

    const getTeamSettings = (size) => {
      return TEAM_SETTINGS[size] || TEAM_SETTINGS[5];
    };

const CyberEscapeGame = () => {
  const [screen, setScreen] = useState('entry');
  const [teamName, setTeamName] = useState('');
  const [teamNumber, setTeamNumber] = useState('');
  const [joinMode, setJoinMode] = useState('create');
  const [role, setRole] = useState(null);
  const [assignedRoles, setAssignedRoles] = useState([]);
  const [showMessage, setShowMessage] = useState(true);
  const [timeLeft, setTimeLeft] = useState(900);
  const [timerStarted, setTimerStarted] = useState(false);
  const [hintsFound, setHintsFound] = useState([]);
  const [hintsUnlocked, setHintsUnlocked] = useState([]);  // 反射ゲームクリア済み（まだ開けていない）
  const hintsUnlockedRef = useRef([]);  // 最新の値を参照
  const hintsFoundRef = useRef([]);  // 最新の値を常に参照できるようにRef
  const teamNumberRef = useRef('');  // teamNumberの最新値
  const myPlayerIdRef = useRef(null);  // myPlayerIdの最新値
  const roleRef = useRef(null);  // 自分の役割（role）の最新値
  const teamSizeRef = useRef(5);  // チームサイズの最新値
  
  // teamSizeを更新する際は必ずこの関数を使用（refも同時に更新）
  const updateTeamSize = (newSize) => {
    console.log('updateTeamSize: ' + newSize);
    setTeamSize(newSize);
    teamSizeRef.current = newSize;
  };

  // 状態をrefに同期
  useEffect(() => { teamNumberRef.current = teamNumber; }, [teamNumber]);
  useEffect(() => { myPlayerIdRef.current = myPlayerId; }, [myPlayerId]);
  useEffect(() => { roleRef.current = role; }, [role]);
  useEffect(() => { teamSizeRef.current = teamSize; }, [teamSize]);
  useEffect(() => { gameCompletedRef.current = gameCompleted; }, [gameCompleted]);
  useEffect(() => { screenRef.current = screen; }, [screen]);
  useEffect(() => { isEscapingRef.current = isEscaping; }, [isEscaping]);
  const [puzzlesSolved, setPuzzlesSolved] = useState([]);
  const [nearbyObject, setNearbyObject] = useState(null);
  const [showHintModal, setShowHintModal] = useState(false);
  const [currentHint, setCurrentHint] = useState(null);
  const [showPuzzleModal, setShowPuzzleModal] = useState(false);
  const [showFinalInputModal, setShowFinalInputModal] = useState(false);  // 最終パズル入力画面
  const [consoleReflexCleared, setConsoleReflexCleared] = useState(false);  // 中央コンソールの反射ゲームクリア済み
  const [puzzleInput, setPuzzleInput] = useState(['', '', '', '', '']);
  const [puzzleError, setPuzzleError] = useState('');
  const [shuffledSymbols, setShuffledSymbols] = useState(['▲', '■', '★', '●', '◆']);
  const [isEscaping, setIsEscaping] = useState(false);  // 脱出処理中フラグ
  const isEscapingRef = useRef(false);
  const [teamSize, setTeamSize] = useState(5);
  const [gameCompleted, setGameCompleted] = useState(false);
  const [showEscapeAnimation, setShowEscapeAnimation] = useState(false);  // 脱出演出表示中
  const [rankings, setRankings] = useState([]);  // ランキングデータ
  const [completionTime, setCompletionTime] = useState(null);
  
  // ボクセルパズル用ステート
  const [showVoxelPuzzle, setShowVoxelPuzzle] = useState(false);
  const [voxelPuzzleType, setVoxelPuzzleType] = useState(null);
  const [currentVoxelHintId, setCurrentVoxelHintId] = useState(null);
  const [voxelPuzzleTarget, setVoxelPuzzleTarget] = useState([]);
  const [voxelPuzzleProgress, setVoxelPuzzleProgress] = useState(0);
  
  // 管理画面用ステート
  const [adminPassword, setAdminPassword] = useState('');
  const [allTeams, setAllTeams] = useState([]);
  const [adminRefreshInterval, setAdminRefreshInterval] = useState(null);
  
  // ロビー画面用ステート
  const [lobbyData, setLobbyData] = useState(null);
  const [selectedRole, setSelectedRole] = useState(null);
  const [roleSelectTimer, setRoleSelectTimer] = useState(45);
  const [myPlayerId, setMyPlayerId] = useState(null);
  const [lobbyRefreshInterval, setLobbyRefreshInterval] = useState(null);
  
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const playerRef = useRef({ x: 0, z: 5, rotation: 0, rotationX: 0 });
  const keysRef = useRef({});
  const isMouseDownRef = useRef(false);
  const lastMouseRef = useRef({ x: 0, y: 0 });
  const animationIdRef = useRef(null);
  const hintObjectsRef = useRef([]);
  const consoleRef = useRef(null);

  // マルチプレイヤーアバター用
  const otherPlayersRef = useRef({});    // 他プレイヤーの位置データ { oderId: { current, target, roleIndex, roleName } }
  const avatarMeshesRef = useRef({});    // アバターメッシュ管理 { oderId: THREE.Group }

  // ボクセルパズルコンポーネント
  // 反射神経ゲームをDOM直接操作で実装（Reactの再レンダリングから完全に独立）
  const reflexGameContainerRef = useRef(null);

  // stale closure対策用ref（interval内で最新の状態を参照するため）
  const gameCompletedRef = useRef(false);
  const screenRef = useRef("entry");

  // ===== localStorage でゲーム状態を保持（ページリフレッシュ対応）=====
  const STORAGE_KEY = 'cyberEscapeGameState';

  // ゲーム状態を保存
  const saveGameState = (stateData) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(stateData));
    } catch (e) { console.error('saveGameState error:', e); }
  };

  // ゲーム状態をクリア
  const clearGameState = () => {
    try {
      localStorage.removeItem(STORAGE_KEY);
    } catch (e) { console.error('clearGameState error:', e); }
  };

  // ページロード時にlocalStorageからゲーム状態を復元（安全版：screenは復元しない）
  useEffect(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const state = JSON.parse(saved);
        // ゲーム中だったら、チーム番号だけ復元してロビーに誘導
        if (state.teamNumber) {
          setTeamNumber(state.teamNumber);
          // 自動的にゲーム画面には行かない（不完全なデータで起動するとエラーになる）
          // ユーザーはエントリー画面でチーム番号を入力してロビーから再開できる
        }
        // localStorage をクリア（次回リロード時のループ防止）
        clearGameState();
      }
    } catch (e) { 
      console.error('ゲーム状態復元エラー:', e);
      clearGameState();
    }
  }, []);

  const startReflexGame = (diff, puzzType, onComp, onCls) => {
    // 既存のゲームがあれば削除
    const existing = document.getElementById('reflex-game-container');
    if (existing) existing.remove();
    
    // コンテナ作成
    const container = document.createElement('div');
    container.id = 'reflex-game-container';
    container.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:99999;display:flex;align-items:center;justify-content:center;';
    document.body.appendChild(container);
    
    // 設定（eスポーツ生徒向け - 高速版）
    const settings = {
      1: { targetCount: 3, spawnInterval: 600, targetLife: 1200, required: 8 },
      2: { targetCount: 4, spawnInterval: 550, targetLife: 1100, required: 10 },
      3: { targetCount: 5, spawnInterval: 520, targetLife: 1050, required: 12 },
      4: { targetCount: 6, spawnInterval: 500, targetLife: 1000, required: 15 },
      5: { targetCount: 7, spawnInterval: 500, targetLife: 1000, required: 18 },
    };
    const config = settings[Math.min(diff, 5)] || settings[2];
    const stars = '★'.repeat(diff) + '☆'.repeat(5-diff);
    const title = puzzType === 'final' ? '🔐 最終認証チャレンジ' : '⚡ 反射神経テスト';
    
    // UI作成
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'background:#1f2937;border:2px solid #00ffff;border-radius:8px;padding:24px;max-width:640px;width:100%;margin:16px;';
    
    const titleEl = document.createElement('h2');
    titleEl.style.cssText = 'color:#00ffff;font-size:24px;font-weight:bold;text-align:center;margin-bottom:16px;';
    titleEl.textContent = title;
    wrapper.appendChild(titleEl);
    
    const contentDiv = document.createElement('div');
    contentDiv.id = 'reflex-content';
    contentDiv.innerHTML = '<div style="text-align:center;padding:32px 0;">' +
      '<p style="color:#d1d5db;margin-bottom:16px;">光るターゲットをクリック！</p>' +
      '<p style="color:#00ffff;margin-bottom:8px;">目標: ' + config.required + '個 / 制限時間: 20秒</p>' +
      '<p style="color:#6b7280;font-size:14px;margin-bottom:24px;">難易度: ' + stars + '</p>' +
      '<button id="reflex-start" style="background:#0891b2;color:white;font-weight:bold;padding:12px 32px;border-radius:8px;font-size:20px;border:none;cursor:pointer;">スタート！</button>' +
      '</div>';
    wrapper.appendChild(contentDiv);
    
    const closeBtn = document.createElement('button');
    closeBtn.style.cssText = 'width:100%;margin-top:16px;background:#374151;color:white;font-weight:bold;padding:8px;border-radius:4px;border:none;cursor:pointer;';
    closeBtn.textContent = '閉じる';
    closeBtn.onclick = function() { container.remove(); onCls(); };
    wrapper.appendChild(closeBtn);
    
    container.appendChild(wrapper);
    
    // スタートボタン
    document.getElementById('reflex-start').onclick = function() {
      var content = document.getElementById('reflex-content');
      var canvas = document.createElement('canvas');
      canvas.id = 'reflex-canvas';
      canvas.width = 560;
      canvas.height = 360;
      canvas.style.cssText = 'width:100%;border-radius:4px;border:1px solid #374151;cursor:crosshair;';
      content.innerHTML = '';
      content.appendChild(canvas);
      
      var ctx = canvas.getContext('2d');
      var W = canvas.width, H = canvas.height;
      
      // ゲーム状態
      var score = 0, timeLeft = 20, targets = [], animId = null, timerId = null;
      var cols = 4, rows = 3, cellW = W/cols, cellH = H/rows;
      var positions = [];
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
          positions.push({ x: c*cellW + cellW/2, y: r*cellH + cellH/2, occupied: false });
        }
      }
      
      var lastSpawn = 0;
      
      function spawnTarget(now) {
        var free = positions.filter(function(p) { return !p.occupied; });
        if (free.length === 0 || targets.length >= config.targetCount) return;
        var pos = free[Math.floor(Math.random() * free.length)];
        pos.occupied = true;
        targets.push({
          x: pos.x, y: pos.y, radius: 40, spawnTime: now, life: config.targetLife,
          pos: pos, hit: false, hue: Math.random()*60+160
        });
      }
      
      function draw(now) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);
        
        ctx.strokeStyle = '#00ffff33';
        for (var i = 1; i < cols; i++) { ctx.beginPath(); ctx.moveTo(i*cellW, 0); ctx.lineTo(i*cellW, H); ctx.stroke(); }
        for (var i = 1; i < rows; i++) { ctx.beginPath(); ctx.moveTo(0, i*cellH); ctx.lineTo(W, i*cellH); ctx.stroke(); }
        
        targets.forEach(function(t) {
          var age = now - t.spawnTime;
          var life = Math.max(0, 1 - age / t.life);
          if (t.hit) {
            ctx.beginPath(); ctx.arc(t.x, t.y, t.radius*1.5*life, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,255,100,' + life + ')'; ctx.fill();
          } else {
            var g = ctx.createRadialGradient(t.x-10, t.y-10, 5, t.x, t.y, t.radius);
            g.addColorStop(0, '#fff');
            g.addColorStop(0.3, 'hsl(' + t.hue + ', 100%, 50%)');
            g.addColorStop(1, '#003');
            ctx.beginPath(); ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
            ctx.fillStyle = g; ctx.fill();
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = life > 0.3 ? '#0f0' : '#f00';
            ctx.fillRect(t.x-30, t.y+t.radius+5, 60*life, 5);
          }
        });
        
        ctx.fillStyle = '#00ffff'; ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'left'; ctx.fillText('SCORE: ' + score + ' / ' + config.required, 10, 30);
        ctx.textAlign = 'right'; ctx.fillStyle = timeLeft <= 5 ? '#f44' : '#fff';
        ctx.fillText('TIME: ' + timeLeft, W-10, 30);
      }
      
      function endGame(won) {
        cancelAnimationFrame(animId);
        clearInterval(timerId);
        if (won) {
          content.innerHTML = '<div style="text-align:center;padding:32px;"><div style="color:#4ade80;font-size:36px;font-weight:bold;">✓ クリア！</div></div>';
          setTimeout(function() { container.remove(); onComp(); }, 1000);
        } else {
          content.innerHTML = '<div style="text-align:center;padding:32px;">' +
            '<div style="color:#f87171;font-size:24px;font-weight:bold;margin-bottom:16px;">タイムアップ...</div>' +
            '<p style="color:#9ca3af;margin-bottom:16px;">スコア: ' + score + ' / ' + config.required + '</p>' +
            '<button id="reflex-retry" style="background:#0891b2;color:white;font-weight:bold;padding:8px 24px;border-radius:4px;border:none;cursor:pointer;">もう一度</button>' +
            '</div>';
          document.getElementById('reflex-retry').onclick = function() { container.remove(); startReflexGame(diff, puzzType, onComp, onCls); };
        }
      }
      
      function loop(now) {
        if (now - lastSpawn > config.spawnInterval) { spawnTarget(now); lastSpawn = now; }
        targets = targets.filter(function(t) {
          var age = now - t.spawnTime;
          if (t.hit && age > 300) { t.pos.occupied = false; return false; }
          if (!t.hit && age > t.life) { t.pos.occupied = false; return false; }
          return true;
        });
        draw(now);
        animId = requestAnimationFrame(loop);
      }
      
      canvas.onclick = function(e) {
        var rect = canvas.getBoundingClientRect();
        var x = (e.clientX - rect.left) * (W / rect.width);
        var y = (e.clientY - rect.top) * (H / rect.height);
        for (var i = targets.length - 1; i >= 0; i--) {
          var t = targets[i];
          if (t.hit) continue;
          if (Math.sqrt(Math.pow(x-t.x, 2) + Math.pow(y-t.y, 2)) < t.radius) {
            t.hit = true; t.spawnTime = performance.now(); score++;
            if (score >= config.required) endGame(true);
            break;
          }
        }
      };
      
      timerId = setInterval(function() {
        timeLeft--;
        if (timeLeft <= 0) endGame(score >= config.required);
      }, 1000);
      
      animId = requestAnimationFrame(loop);
    };
  };

  // 難易度に応じたパズル形状を生成（全て1段目のみ）
  const generatePuzzleShape = (difficulty) => {
    const shapes = {
      // 2人チーム用（簡単）- 2ブロック（横並び）
      1: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 }
      ],
      // 3人チーム用 - 3ブロック（L字）
      2: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 }
      ],
      // 4人チーム用 - 4ブロック（T字）
      3: [
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 2, y: 0, z: 1 },
        { x: 1, y: 0, z: 0 }
      ],
      // 5人チーム用 - 5ブロック（十字）
      4: [
        { x: 1, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 2, y: 0, z: 1 },
        { x: 1, y: 0, z: 2 }
      ],
      // 最終パズル用 - 7ブロック（大きな形状）
      5: [
        { x: 0, y: 0, z: 0 },
        { x: 1, y: 0, z: 0 },
        { x: 2, y: 0, z: 0 },
        { x: 0, y: 0, z: 1 },
        { x: 1, y: 0, z: 1 },
        { x: 0, y: 0, z: 2 },
        { x: 1, y: 0, z: 2 }
      ]
    };
    return shapes[Math.min(difficulty, 5)] || shapes[1];
  };

  // チーム人数から難易度を計算（全チーム難易度4に統一）
  const getDifficultyFromTeamSize = (size) => {
    return getTeamSettings(size).difficulty;
  };

  // 管理画面: 全チームデータを取得
  const fetchAllTeams = async () => {
    try {
      const teams = await supabase.getAllTeams();
      console.log('fetchAllTeams: 取得結果', teams);
      if (teams && teams.length > 0) {
        const formattedTeams = teams.map(function(t) {
          return Object.assign({}, t.data || {}, { name: t.name, number: t.code, code: t.code });
        });
        // クリアタイム順、未クリアは進捗順にソート
        formattedTeams.sort(function(a, b) {
          if (a.completed && b.completed) {
            return (a.completionTime || 9999) - (b.completionTime || 9999);
          }
          if (a.completed) return -1;
          if (b.completed) return 1;
          return (b.hintsFound?.length || 0) - (a.hintsFound?.length || 0);
        });
        setAllTeams(formattedTeams);
      } else {
        setAllTeams([]);
      }
    } catch (error) {
      console.error('Error fetching teams:', error);
      setAllTeams([]);
    }
  };

  // 管理画面に入る
  const enterAdminScreen = () => {
    if (adminPassword === 'admin123') {
      setScreen('admin');
      fetchAllTeams();
      // 5秒ごとに更新
      const interval = setInterval(fetchAllTeams, 5000);
      setAdminRefreshInterval(interval);
    } else {
      alert('パスワードが違います');
    }
  };

  // 管理画面から退出
  const exitAdminScreen = () => {
    if (adminRefreshInterval) {
      clearInterval(adminRefreshInterval);
      setAdminRefreshInterval(null);
    }
    setScreen('entry');
    setAdminPassword('');
  };

  // チームの残り時間を計算（チームサイズに応じた制限時間）
  const getTeamTimeLeft = (team) => {
    const teamTimeLimit = getTeamSettings(team.maxMembers || 5).timeLimit;
    if (!team.startTime) return teamTimeLimit;
    if (team.completed) return teamTimeLimit - (team.completionTime || 0);
    const elapsed = Math.floor((Date.now() - team.startTime) / 1000);
    return Math.max(0, teamTimeLimit - elapsed);
  };

  // 全チームリセット
  const resetAllTeams = async () => {
    if (!confirm('全てのチームデータを削除しますか？この操作は取り消せません。')) return;
    try {
      const teams = await supabase.getAllTeams();
      console.log('resetAllTeams: 取得したチーム', teams);
      if (teams && teams.length > 0) {
        for (var i = 0; i < teams.length; i++) {
          console.log('resetAllTeams: 削除中', teams[i].code);
          await supabase.deleteTeam(teams[i].code);
        }
      }
      setAllTeams([]);
      alert('全チームデータを削除しました');
    } catch (error) {
      console.error('Error resetting teams:', error);
      alert('削除に失敗しました');
    }
  };

  // ロビーデータを取得
  const fetchLobbyData = async () => {
    const team = await supabase.getTeam(teamNumber);
    if (team) {
      const data = team.data;
      data.name = team.name;
      data.number = team.number;
      setLobbyData(data);
      
      // 全員揃ったらロビー開始時刻をセット
      const maxMembers = data.maxMembers || team.size || 2;
      const allJoined = data.members && data.members.length >= maxMembers;
      
      if (allJoined && !data.lobbyStartTime) {
        data.lobbyStartTime = Date.now();
        await supabase.updateTeam(teamNumber, data);
      }
      
      // 残り時間を計算（全員揃ってから）
      if (data.lobbyStartTime) {
        const elapsed = Math.floor((Date.now() - data.lobbyStartTime) / 1000);
        const remaining = Math.max(0, 45 - elapsed);
        setRoleSelectTimer(remaining);
        
        // タイムアップでゲーム開始（役割未選択でも自動割り当て）
        if (remaining <= 0 && !data.gameStarted) {
          autoAssignAndStart(data);
        }
      }
      
      // ゲームが開始されていたら自分も移行
      if (data.gameStarted) {
        const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
        if (myEntry) {
          const availableRoles = getRolesForTeamSize(data.maxMembers || team.size || 2);
          // 役割が未割り当ての場合は空いている役割を割り当て
          if (myEntry.roleIndex === undefined) {
            const takenRoles = data.members.filter(function(m) { return m.roleIndex !== undefined && m.oderId !== myPlayerId; }).map(function(m) { return m.roleIndex; });
            for (var i = 0; i < availableRoles.length; i++) {
              if (!takenRoles.includes(i)) {
                myEntry.roleIndex = i;
                break;
              }
            }
          }
          if (myEntry.roleIndex !== undefined) {
            setRole(availableRoles[myEntry.roleIndex]);
            setAssignedRoles([availableRoles[myEntry.roleIndex]]);
            setSelectedRole(myEntry.roleIndex);
            const currentTeamSize = data.maxMembers || team.size || 2;
            console.log('lobbyGameStarted: data.maxMembers=' + data.maxMembers + ', team.size=' + team.size + ', setting=' + currentTeamSize);
            updateTeamSize(currentTeamSize);
            setTimeLeft(getTeamSettings(currentTeamSize).timeLimit);
            // チームのヒントを読み込み（数値型に統一）
            if (data.hintsFound) {
              const hints = data.hintsFound.map(Number);
              setHintsFound(hints);
              hintsFoundRef.current = hints;
            }
            setShowMessage(true);
            setTimerStarted(true);

            // ゲーム状態をlocalStorageに保存
            const lobbyRole = availableRoles[myEntry.roleIndex];
            saveGameState({
              teamNumber: teamNumber,
              teamSize: currentTeamSize,
              myPlayerId: myPlayerId,
              selectedRole: myEntry.roleIndex,
              role: lobbyRole,
              screen: 'game'
            });

            setScreen('game');
          }
        }
      }
    }
  };

  // 役割を選択
  const selectRole = async (roleIndex) => {
    if (!lobbyData || selectedRole !== null) return;
    
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const data = team.data;
    
    // 既に誰かが選んでいないかチェック
    const alreadyTaken = data.members.some(function(m) { return m.roleIndex === roleIndex; });
    if (alreadyTaken) {
      alert('この役割は既に選ばれています');
      fetchLobbyData();
      return;
    }
    
    // 自分のエントリを更新
    const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
    if (myEntry) {
      myEntry.roleIndex = roleIndex;
      const availableRoles = getRolesForTeamSize(data.maxMembers || teamSize);
      myEntry.roleName = availableRoles[roleIndex].name;
      await supabase.updateTeam(teamNumber, data);
      setSelectedRole(roleIndex);
      setLobbyData(data);
    }
  };

  // 自動割り当てしてゲーム開始
  const autoAssignAndStart = async (oldData) => {
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const latestData = team.data;
    
    if (latestData.gameStarted) return;
    
    // team.sizeを使用（teamSize状態はstale closureになる可能性があるため）
    const maxMembers = latestData.maxMembers || team.size || 2;
    const availableRoles = getRolesForTeamSize(maxMembers);
    
    // 未選択のメンバーに役割を自動割り当て
    const takenRoles = latestData.members.filter(function(m) { return m.roleIndex !== undefined; }).map(function(m) { return m.roleIndex; });
    const freeRoles = [];
    
    for (let i = 0; i < availableRoles.length; i++) {
      if (!takenRoles.includes(i)) {
        freeRoles.push(i);
      }
    }
    
    latestData.members.forEach(member => {
      if (member.roleIndex === undefined && freeRoles.length > 0) {
        member.roleIndex = freeRoles.shift();
        member.roleName = availableRoles[member.roleIndex].name;
        member.autoAssigned = true;
      }
    });
    
    latestData.gameStarted = true;
    latestData.startTime = Date.now();
    await supabase.updateTeam(teamNumber, latestData);
    
    // 自分の役割を設定してゲーム画面へ
    const myEntry = latestData.members.find(function(m) { return m.oderId === myPlayerId; });
    if (!myEntry) {
      console.error('autoAssignAndStart: myEntryが見つからない myPlayerId=' + myPlayerId);
      return;
    }
    if (myEntry.roleIndex === undefined) {
      console.error('autoAssignAndStart: roleIndexが未定義');
      return;
    }
    const myRole = availableRoles[myEntry.roleIndex];
    console.log('autoAssignAndStart: maxMembers=' + maxMembers + ', myRole=' + myRole.id + ', roleIndex=' + myEntry.roleIndex);
    setRole(myRole);
    setAssignedRoles([myRole]);
    setSelectedRole(myEntry.roleIndex);
    
    updateTeamSize(maxMembers);
    setTimeLeft(getTeamSettings(maxMembers).timeLimit);
    // チームのヒントを読み込み（数値型に統一）
    if (latestData.hintsFound) {
      const hints = latestData.hintsFound.map(Number);
      setHintsFound(hints);
      hintsFoundRef.current = hints;
    }
    setTimerStarted(true);

    // ゲーム状態をlocalStorageに保存
    if (myEntry && myEntry.roleIndex !== undefined) {
      const savedRole = availableRoles[myEntry.roleIndex];
      saveGameState({
        teamNumber: teamNumber,
        teamSize: maxMembers,
        myPlayerId: myPlayerId,
        selectedRole: myEntry.roleIndex,
        role: savedRole,
        screen: 'game'
      });
    }

    setScreen('game');
  };

  // ロビーに入る
  const enterLobby = async () => {
    console.log('enterLobby: チーム番号を検索中...', teamNumber);
    const team = await supabase.getTeam(teamNumber);
    console.log('enterLobby: 検索結果:', team);
    if (!team) {
      alert('チームが見つかりません（番号: ' + teamNumber + '）');
      return;
    }
    const data = team.data;
    
    // 既にゲーム開始済みなら直接ゲームへ（途中参加）
    if (data.gameStarted) {
      alert('ゲームは既に開始されています');
      return;
    }
    
    // 人数上限チェック
    if (data.members && data.members.length >= data.maxMembers) {
      alert('チームは満員です');
      return;
    }
    
    // プレイヤーIDを生成
    const oderId = 'P' + Date.now();
    setMyPlayerId(oderId);
    
    // メンバーとして追加
    if (!data.members) data.members = [];
    data.members.push({
      oderId: oderId,
      joinTime: Date.now(),
      roleIndex: undefined,
      roleName: undefined
    });
    
    await supabase.updateTeam(teamNumber, data);
    setLobbyData(data);
    // 重要: チームサイズを正しく設定（data.maxMembers または team.size から）
    const lobbyTeamSize = data.maxMembers || team.size || 5;
    console.log('enterLobby: data.maxMembers=' + data.maxMembers + ', team.size=' + team.size + ', setting teamSize=' + lobbyTeamSize);
    updateTeamSize(lobbyTeamSize);
    setRoleSelectTimer(45);
    setScreen('lobby');
  };

  // テスト用：ダミーメンバー追加
  const forceFullTeam = async () => {
    const team = await supabase.getTeam(teamNumber);
    if (team) {
      const data = team.data;
      const maxMembers = data.maxMembers || teamSize;
      while (data.members.length < maxMembers) {
        data.members.push({
          oderId: 'DUMMY' + Date.now() + Math.random(),
          joinTime: Date.now(),
          roleIndex: undefined
        });
      }
      await supabase.updateTeam(teamNumber, data);
      setLobbyData(data);
      fetchLobbyData();
      alert('テスト用にダミーメンバーを追加しました');
    }
  };

  // ロビーから退出
  const exitLobby = () => {
    if (lobbyRefreshInterval) {
      clearInterval(lobbyRefreshInterval);
      setLobbyRefreshInterval(null);
    }
    clearGameState();  // localStorageをクリア
    setScreen('entry');
    setSelectedRole(null);
    setLobbyData(null);
    setMyPlayerId(null);
  };

  // 準備完了（役割確定してゲーム開始待ち）
  const confirmRoleAndWait = async () => {
    if (selectedRole === null) {
      alert('役割を選んでください');
      return;
    }
    
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;
      
      const myEntry = data.members.find(function(m) { return m.oderId === myPlayerId; });
      if (myEntry) {
        myEntry.ready = true;
        await supabase.updateTeam(teamNumber, data);
      }
      
      // 全員準備完了かチェック
      const allReady = data.members.every(function(m) { return m.ready; });
      if (allReady && data.members.length >= 2) {
        await autoAssignAndStart(data);
      }
    } catch (error) {
      console.error('Confirm role error:', error);
    }
  };

  // ロビータイマー
  useEffect(() => {
    if (screen === 'lobby' && roleSelectTimer > 0) {
      const timer = setTimeout(() => {
        setRoleSelectTimer(prev => Math.max(0, prev - 1));
      }, 1000);
      return () => clearTimeout(timer);
    } else if (screen === 'lobby' && roleSelectTimer === 0 && lobbyData && !lobbyData.gameStarted) {
      autoAssignAndStart(lobbyData);
    }
  }, [screen, roleSelectTimer, lobbyData]);

  // ロビー終了時のクリーンアップ
  useEffect(() => {
    return () => {
      if (lobbyRefreshInterval) {
        clearInterval(lobbyRefreshInterval);
      }
    };
  }, [lobbyRefreshInterval]);

  // 役割定義（5種類）- シークレットメッセージ3行
  // 役割定義（人数に応じて使用）
  const roleDefinitions = {
    leader: { id: 'leader', name: 'リーダー', icon: '👑', color: '#ffd700' },
    decoder: { id: 'decoder', name: '解読員', icon: '🔓', color: '#ff6b6b' },
    investigator: { id: 'investigator', name: '調査員', icon: '🔍', color: '#4ecdc4' },
    analyst: { id: 'analyst', name: '分析員', icon: '📊', color: '#95e1d3' },
    communicator: { id: 'communicator', name: '通信員', icon: '📡', color: '#dda0dd' },
  };

  // 人数別役割リスト
  const getRolesForTeamSize = (size) => {
    const r = roleDefinitions;
    switch(size) {
      case 2: return [r.leader, r.decoder];
      case 3: return [r.leader, r.decoder, r.investigator];
      case 4: return [r.leader, r.decoder, r.investigator, r.analyst];
      case 5: return [r.leader, r.decoder, r.investigator, r.analyst, r.communicator];
      default: return [r.leader, r.decoder];
    }
  };

  // 人数別シークレットメッセージ
  const getSecretMessage = (size, roleId) => {
    const messages = {
      2: {
        leader: ['【指令】最終入力はあなたが行う', '図形の「角の数」が順番を決める', '色と形の対応：青=▲ 緑=■ 黄=★', '【探索】部屋のクリスタルに何かある'],
        decoder: ['【受信】数列：3, 4, 5, 0, 4', '角の数が順番になっている', '色と形の対応：赤=● 紫=◆', '【探索】部屋のクリスタルを調べろ'],
      },
      3: {
        leader: ['【指令】最終入力はあなたが行う', '図形の「角の数」が順番を決める', '仲間から色と形の対応を聞け', '【探索】部屋のクリスタルに何かある'],
        decoder: ['【受信】数列：3, 4, 5, 0, 4', '角の数が順番になっている', '【探索】クリスタルを調べろ'],
        investigator: ['【報告】色と形の対応を発見', '青=▲ 緑=■ 黄=★', '赤=● 紫=◆', '【探索】クリスタルにヒントがある'],
      },
      4: {
        leader: ['【指令】最終入力はあなたが行う', '角の数で順番が決まるらしい', '【探索】部屋のクリスタルに何かある'],
        decoder: ['【受信】法則は「角の数」', '3角→4角→5角→?→?', '【探索】クリスタルを調べろ'],
        investigator: ['【報告】色と形の対応を発見', '青=▲ 緑=■ 黄=★', '赤=● 紫=◆'],
        analyst: ['【解析】完全な数列を発見', '3, 4, 5, 0, 4', '【探索】クリスタルにヒントがある'],
      },
      5: {
        leader: ['【指令】最終入力を行う', '答えは5つの形の順番', '【探索】部屋のクリスタルに何かある'],
        decoder: ['【受信】法則は「角の数」', '角の数で順番が決まる', '【探索】クリスタルを調べろ'],
        investigator: ['【報告】色と形の対応', '青=▲ 緑=■ 黄=★', '残りは通信員が知っている'],
        analyst: ['【解析】数列を発見', '3, 4, 5, 0, 4', '0角は丸のこと'],
        communicator: ['【傍受】残りの対応を解読', '赤=● 紫=◆', '【探索】クリスタルにヒントがある'],
      },
    };
    return messages[size]?.[roleId] || ['情報なし'];
  };

  // 人数別フィールドヒント
  const getFieldHints = (size, roleId) => {
    const hints = {
      2: {
        leader: ['▲は1番目', '★は3番目', '●は■より後ろ'],
        decoder: ['数列：3, 4, 5, ?, ?', '■は2番目', '◆は最後'],
      },
      3: {
        leader: ['1番目は3角の形', '4角の形は2つある'],
        decoder: ['数列：3, 4, 5, 0, 4', 'この数列が順番を決める'],
        investigator: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'],
      },
      4: {
        leader: ['答えは5つの形の列'],
        decoder: ['角の数で順番が決まる', '3番目は5角'],
        investigator: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'],
        analyst: ['数列完成：3,4,5,0,4', '4番目は0'],
      },
      5: {
        leader: ['全員の情報を統合せよ'],
        decoder: ['角の数が順番の法則'],
        investigator: ['青=▲ 緑=■', '黄=★ 赤=● 紫=◆'],
        analyst: ['数列：3,4,5,0,4'],
        communicator: ['4角の形は2つある', '■が先、◆が後'],
      },
    };
    return hints[size]?.[roleId] || [];
  };

  // 共通ヒント
  const commonHints = [
    { location: '入口の壁', text: '5つの形が扉を開く' },
    { location: '中央の床', text: '▲=3角 ■=4角 ★=5角 ●=0角 ◆=4角' },
    { location: '本棚', text: '角の数に注目せよ' },
  ];

  // 正解（図形の順番）
  const correctAnswer = ['▲', '■', '★', '●', '◆'];
  const shapes = ['▲', '■', '★', '●', '◆'];

  // 後方互換のためのrolesゲッター
  const roles = getRolesForTeamSize(teamSize);
  const correctNumbers = ['7', '3', '1', '9', '5'];

  // 人数別の役割割り当て
  const getRoleAssignments = (memberCount, memberIndex) => {
    if (memberCount >= 5) {
      return [roles[memberIndex % 5]];
    } else if (memberCount === 4) {
      const assignments = [
        [roles[0]], // セキュリティ
        [roles[1]], // データ
        [roles[2]], // ネットワーク
        [roles[3], roles[4]] // システム + AI
      ];
      return assignments[memberIndex % 4];
    } else if (memberCount === 3) {
      const assignments = [
        [roles[0], roles[1]], // セキュリティ + データ
        [roles[2], roles[3]], // ネットワーク + システム
        [roles[4]] // AI
      ];
      return assignments[memberIndex % 3];
    } else {
      const assignments = [
        [roles[0], roles[1], roles[2]], // セキュリティ + データ + ネットワーク
        [roles[3], roles[4]] // システム + AI
      ];
      return assignments[memberIndex % 2];
    }
  };

  // マイクラ風アバター作成関数
  const createMinecraftAvatar = (roleColor) => {
    const avatarGroup = new THREE.Group();

    const skinColor = 0xffdbac;
    const bodyColor = new THREE.Color(roleColor);
    const pantsColor = 0x3a3a5a;

    // 頭部
    const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMaterial = new THREE.MeshStandardMaterial({
      color: skinColor, roughness: 0.8, metalness: 0.1
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    head.castShadow = true;
    avatarGroup.add(head);

    // 胴体
    const bodyGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const bodyMaterial = new THREE.MeshStandardMaterial({
      color: bodyColor, roughness: 0.7, metalness: 0.2,
      emissive: bodyColor, emissiveIntensity: 0.15
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.0;
    body.castShadow = true;
    avatarGroup.add(body);

    // 腕
    const armGeometry = new THREE.BoxGeometry(0.15, 0.5, 0.15);
    const armMaterial = new THREE.MeshStandardMaterial({
      color: skinColor, roughness: 0.8, metalness: 0.1
    });
    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.275, 1.0, 0);
    leftArm.castShadow = true;
    avatarGroup.add(leftArm);

    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.275, 1.0, 0);
    rightArm.castShadow = true;
    avatarGroup.add(rightArm);

    // 脚
    const legGeometry = new THREE.BoxGeometry(0.18, 0.5, 0.18);
    const legMaterial = new THREE.MeshStandardMaterial({
      color: pantsColor, roughness: 0.9, metalness: 0.05
    });
    const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.1, 0.4, 0);
    leftLeg.castShadow = true;
    avatarGroup.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
    rightLeg.position.set(0.1, 0.4, 0);
    rightLeg.castShadow = true;
    avatarGroup.add(rightLeg);

    avatarGroup.userData = {
      isAvatar: true, head, body, leftArm, rightArm, leftLeg, rightLeg
    };

    return avatarGroup;
  };

  // 役割名ラベル作成関数
  const createRoleLabel = (roleName, color) => {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

    // 背景
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.beginPath();
    ctx.roundRect(0, 0, 256, 64, 8);
    ctx.fill();

    // 枠線
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(0, 0, 256, 64, 8);
    ctx.stroke();

    // テキスト
    ctx.font = 'bold 28px "Hiragino Sans", "Meiryo", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = color;
    ctx.fillText(roleName, 128, 32);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;

    const spriteMaterial = new THREE.SpriteMaterial({
      map: texture, transparent: true, depthTest: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.y = 2.0;
    sprite.scale.set(1.2, 0.3, 1);

    return sprite;
  };

  // Supabase設定
  const SUPABASE_URL = 'https://nqvpjmwvrtvbhojeotmx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5xdnBqbXd2cnR2YmhvamVvdG14Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjczNTAxMTksImV4cCI6MjA4MjkyNjExOX0.NbacfvbI6MpuCv1ckTRWQroFrZWugKy9tYwHslaUm70';

  // Supabase APIヘルパー
  const supabase = {
    async getTeam(code) {
      try {
        console.log('getTeam: 検索コード:', code);
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code + '&select=*',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        console.log('getTeam: HTTPステータス:', res.status);
        const data = await res.json();
        console.log('getTeam: レスポンス:', data);
        return data && data.length > 0 ? data[0] : null;
      } catch (e) { console.error('getTeam error:', e); return null; }
    },
    async createTeam(code, name, teamData) {
      try {
        console.log('createTeam: 作成開始:', { code, name, teamData });
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams',
          {
            method: 'POST',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
              'Content-Type': 'application/json',
              'Prefer': 'return=representation'
            },
            body: JSON.stringify({ code: code, name: name, size: teamData.maxMembers, data: teamData })
          }
        );
        console.log('createTeam: HTTPステータス:', res.status);
        const result = await res.json();
        console.log('createTeam: レスポンス:', result);
        // HTTPエラーの場合はエラーオブジェクトを返す
        if (!res.ok) {
          return { error: true, status: res.status, ...result };
        }
        return result;
      } catch (e) { console.error('createTeam error:', e); return null; }
    },
    async updateTeam(code, teamData) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code,
          {
            method: 'PATCH',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ data: teamData })
          }
        );
        return res.ok;
      } catch (e) { console.error('updateTeam error:', e); return false; }
    },
    async getAllTeams() {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?select=*&order=created_at.desc',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        return await res.json();
      } catch (e) { console.error('getAllTeams error:', e); return []; }
    },
    async deleteTeam(code) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?code=eq.' + code,
          {
            method: 'DELETE',
            headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY }
          }
        );
        return res.ok;
      } catch (e) { console.error('deleteTeam error:', e); return false; }
    },
    async getTeamByName(name) {
      try {
        const res = await fetch(
          SUPABASE_URL + '/rest/v1/teams?name=eq.' + encodeURIComponent(name) + '&select=*',
          { headers: { 'apikey': SUPABASE_ANON_KEY, 'Authorization': 'Bearer ' + SUPABASE_ANON_KEY } }
        );
        const data = await res.json();
        return data && data.length > 0 ? data[0] : null;
      } catch (e) { console.error('getTeamByName error:', e); return null; }
    }
  };

  // チーム作成
  const handleCreateTeam = async () => {
    if (!teamName.trim()) return;

    // チーム名の重複チェック
    const existingByName = await supabase.getTeamByName(teamName.trim());
    if (existingByName) {
      alert('このチーム名は既に使用されています。\n別の名前を入力してください。');
      return;
    }

    // 4桁のランダムな数字（1000-9999）
    const teamNum = String(1000 + Math.floor(Math.random() * 9000));

    // チーム番号の重複チェック
    const existing = await supabase.getTeam(teamNum);
    if (existing) {
      handleCreateTeam();
      return;
    }
    
    console.log('createTeam: teamSize state=' + teamSize);
    const teamData = {
      maxMembers: teamSize,
      members: [],
      lobbyStartTime: null,
      gameStarted: false,
      startTime: null,
      hintsFound: [],
      puzzlesSolved: [],
      completed: false,
      completionTime: null,
      createdAt: Date.now()
    };
    
    const result = await supabase.createTeam(teamNum, teamName, teamData);

    // チーム作成が失敗した場合
    // 注意: result.codeはチームコードなのでエラーチェックに含めない
    if (!result || result.error || result.message || (Array.isArray(result) && result.length === 0)) {
      console.error('チーム作成エラー:', result);
      const errorMsg = result?.message || 'チームの作成に失敗しました';
      alert(errorMsg + '\nもう一度お試しください。');
      return;
    }

    // 作成成功を確認
    console.log('チーム作成成功:', teamNum, result);

    setTeamNumber(teamNum);
    setScreen('waiting');
  };

  // チーム参加（直接ロビーへ）
  const handleJoinTeam = async () => {
    if (!teamNumber.trim()) return;

    // 数字のみに正規化
    const normalizedNumber = teamNumber.replace(/\D/g, '');
    const team = await supabase.getTeam(normalizedNumber);
    if (!team) {
      alert('チームが見つかりません。チーム番号を確認してください。');
      return;
    }

    const teamData = team.data;

    // 人数上限チェック
    if (teamData.members && teamData.members.length >= teamData.maxMembers) {
      alert('このチームは満員です（' + teamData.maxMembers + '人）');
      return;
    }

    // ゲーム開始済みチェック
    if (teamData.gameStarted) {
      alert('このチームはすでにゲームを開始しています');
      return;
    }

    setTeamName(team.name);
    setTeamNumber(normalizedNumber);
    const joinTeamSize = teamData.maxMembers || team.size || 5;
    console.log('joinTeam: data.maxMembers=' + teamData.maxMembers + ', team.size=' + team.size + ', setting=' + joinTeamSize);
    updateTeamSize(joinTeamSize);

    // プレイヤーIDを生成してメンバーとして追加
    const oderId = 'P' + Date.now();
    setMyPlayerId(oderId);

    if (!teamData.members) teamData.members = [];
    teamData.members.push({
      oderId: oderId,
      joinTime: Date.now(),
      roleIndex: undefined,
      roleName: undefined
    });

    await supabase.updateTeam(normalizedNumber, teamData);
    setLobbyData(teamData);
    setRoleSelectTimer(45);
    setScreen('lobby');  // 直接ロビーへ
  };

  // ゲーム開始（ロビー経由）
  const handleStartGame = async () => {
    if (selectedRole === null) {
      alert('役割を選んでください');
      return;
    }
    
    const team = await supabase.getTeam(teamNumber);
    if (!team) return;
    const data = team.data;
    
    const maxMembers = data.maxMembers || teamSize;
    updateTeamSize(maxMembers);  // 重要: チームサイズを正しく設定
    const availableRoles = getRolesForTeamSize(maxMembers);
    
    // 未選択者に自動割り当て
    const takenRoles = data.members.filter(function(m) { return m.roleIndex !== undefined; }).map(function(m) { return m.roleIndex; });
    const freeRoles = [];
    for (var i = 0; i < availableRoles.length; i++) {
      if (!takenRoles.includes(i)) freeRoles.push(i);
    }
    
    data.members.forEach(function(member) {
      if (member.roleIndex === undefined && freeRoles.length > 0) {
        member.roleIndex = freeRoles.shift();
        member.roleName = availableRoles[member.roleIndex]?.name;
        member.autoAssigned = true;
      }
    });
    
    data.gameStarted = true;
    data.startTime = Date.now();
    await supabase.updateTeam(teamNumber, data);
    
    const gameRole = availableRoles[selectedRole];
    setRole(gameRole);
    setAssignedRoles([gameRole]);
    setTimeLeft(getTeamSettings(maxMembers).timeLimit);
    // チームのヒントを読み込み（数値型に統一）
    if (data.hintsFound) {
      const hints = data.hintsFound.map(Number);
      setHintsFound(hints);
      hintsFoundRef.current = hints;
    }
    setShowMessage(true);
    setTimerStarted(true);

    // ゲーム状態をlocalStorageに保存
    saveGameState({
      teamNumber: teamNumber,
      teamSize: maxMembers,
      myPlayerId: myPlayerId,
      selectedRole: selectedRole,
      role: gameRole,
      screen: 'game'
    });

    setScreen('game');
  };

  // ゲーム開始時にチームのhintsFoundを読み込む
  const loadTeamHints = async () => {
    try {
      const team = await supabase.getTeam(teamNumber);
      if (team && team.data && team.data.hintsFound) {
        const hints = team.data.hintsFound.map(Number);
        setHintsFound(hints);
        hintsFoundRef.current = hints;
      }
    } catch (e) { console.error('loadTeamHints error:', e); }
  };

  // 自分の位置をサーバーに送信（hintsUnlocked/hintsFoundを保持）
  const updateMyPosition = async () => {
    // ゲーム完了時は位置更新を停止（completionTimeの上書き防止）
    if (gameCompletedRef.current || isEscapingRef.current) return;
    if (!teamNumber || !myPlayerId) return;
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;
      
      // サーバー側でゲーム完了していたら、このクライアントも完了状態に
      if (data.completed) {
        console.log('updateMyPosition: サーバー側で完了検知');
        return;  // 位置更新せず、fetchOtherPlayersに任せる
      }
      
      const myEntry = data.members.find(m => m.oderId === myPlayerId);
      if (myEntry) {
        const player = playerRef.current;
        myEntry.position = {
          x: Math.round(player.x * 100) / 100,
          z: Math.round(player.z * 100) / 100,
          rotation: Math.round(player.rotation * 100) / 100,
          lastUpdate: Date.now()
        };
        // ローカルのhintsUnlocked/hintsFoundをマージして保持
        const localUnlocked = (hintsUnlockedRef.current || []).map(Number);
        const serverUnlocked = (data.hintsUnlocked || []).map(Number);
        data.hintsUnlocked = [...new Set([...localUnlocked, ...serverUnlocked])];

        const localFound = (hintsFoundRef.current || []).map(Number);
        const serverFound = (data.hintsFound || []).map(Number);
        data.hintsFound = [...new Set([...localFound, ...serverFound])];

        // ★ 保存直前に完了状態を再確認（レース条件対策）
        // リーダーが完了保存した直後に非リーダーが上書きするのを防ぐ
        const freshTeam = await supabase.getTeam(teamNumber);
        if (freshTeam && freshTeam.data && freshTeam.data.completed) {
          console.log('updateMyPosition: 保存直前に完了検知、保存スキップ');
          // 完了状態を検知したので、自分も完了状態に遷移
          if (!gameCompletedRef.current) {
            gameCompletedRef.current = true;
            isEscapingRef.current = true;
          }
          return;  // 位置更新をスキップして完了データを保護
        }

        await supabase.updateTeam(teamNumber, data);
      }
    } catch (e) { console.error('updateMyPosition error:', e); }
  };

  // 他プレイヤーの位置とヒント情報を取得
  const fetchOtherPlayers = async () => {
    // stale closure対策: refで現在の画面とゲーム完了状態を確認
    if (screenRef.current !== "game") return;
    if (!teamNumber || !myPlayerId) return;
    try {
      const team = await supabase.getTeam(teamNumber);
      if (!team) return;
      const data = team.data;

      // ゲーム完了状態をチェック（リーダー以外のメンバー用）
      if (data.completed && !gameCompletedRef.current) {
        console.log('ゲーム完了を検知！ 完了画面へ遷移します');
        // refを即座に更新（次のinterval tickでの重複実行を防止）
        isEscapingRef.current = true;
        setIsEscaping(true);
        gameCompletedRef.current = true;
        setGameCompleted(true);
        setCompletionTime(data.completionTime || 0);
        clearGameState();
        // ランキングを取得
        try {
          const allTeams = await supabase.getAllTeams();
          const completedTeams = allTeams
            .filter(t => t.data && t.data.completed)
            .map(t => ({
              name: t.name,
              code: t.code,
              time: t.data.completionTime,
              size: t.data.maxMembers || t.size || 5
            }))
            .sort((a, b) => a.time - b.time);
          setRankings(completedTeams);
        } catch (e) { console.error('fetchRankings error:', e); }
        // 脱出アニメーション画面へ遷移（全員に表示）
        screenRef.current = 'escaping';
        setScreen('escaping');
        return;
      }

      // チームのhintsFoundを同期（数値型に統一）
      if (data.hintsFound && data.hintsFound.length > 0) {
        const supabaseHints = data.hintsFound.map(Number);
        setHintsFound(prev => {
          const prevNums = prev.map(Number);
          const merged = [...new Set([...prevNums, ...supabaseHints])];
          return merged.length !== prevNums.length ? merged : prev;
        });
        hintsFoundRef.current = [...new Set([...(hintsFoundRef.current || []).map(Number), ...supabaseHints])];
      }

      // チームのhintsUnlockedを同期（数値型に統一）
      if (data.hintsUnlocked && data.hintsUnlocked.length > 0) {
        const supabaseUnlocked = data.hintsUnlocked.map(Number);
        setHintsUnlocked(prev => {
          const prevNums = prev.map(Number);
          const merged = [...new Set([...prevNums, ...supabaseUnlocked])];
          return merged.length !== prevNums.length ? merged : prev;
        });
        hintsUnlockedRef.current = [...new Set([...(hintsUnlockedRef.current || []).map(Number), ...supabaseUnlocked])];
      }

      data.members.forEach(member => {
        if (member.oderId === myPlayerId) return;
        if (!member.position) return;

        const existing = otherPlayersRef.current[member.oderId];
        if (existing) {
          existing.target = { ...member.position };
        } else {
          otherPlayersRef.current[member.oderId] = {
            current: { ...member.position },
            target: { ...member.position },
            roleIndex: member.roleIndex,
            roleName: member.roleName
          };
        }
      });

      // 切断したプレイヤーを削除
      const activeIds = data.members.map(m => m.oderId);
      Object.keys(otherPlayersRef.current).forEach(id => {
        if (!activeIds.includes(id)) {
          delete otherPlayersRef.current[id];
        }
      });
    } catch (e) { console.error('fetchOtherPlayers error:', e); }
  };

  // 人数別：誰がどのヒントを見れるか
  const getHintPermissions = (size, roleId) => {
    // hintId: 0=リーダー, 1=解読員, 2=調査員, 3=分析員, 4=通信員 のモニュメント
    const permissions = {
      2: {
        leader: [0, 1],        // リーダーは2つ見れる
        decoder: [2, 3, 4],    // 解読員は3つ見れる（両者参加必須）
      },
      3: {
        leader: [0, 1],        // リーダーは2つ
        decoder: [2, 3],       // 解読員は2つ
        investigator: [4],     // 調査員は1つ
      },
      4: {
        leader: [0],
        decoder: [1, 2],       // 解読員は2つ
        investigator: [3],
        analyst: [4],
      },
      5: {
        leader: [0],
        decoder: [1],
        investigator: [2],
        analyst: [3],
        communicator: [4],
      },
    };
    return permissions[size]?.[roleId] || [];
  };

  // ヒント取得（二段階システム：反射ゲーム→権限者が開封）
  // Supabaseから最新状態を取得してから判定
  const collectHint = async (hintId) => {
    const hintInfo = [
      { name: 'リーダー', color: '#ffd700', roleId: 'leader' },
      { name: '解読員', color: '#ff6b6b', roleId: 'decoder' },
      { name: '調査員', color: '#4ecdc4', roleId: 'investigator' },
      { name: '分析員', color: '#95e1d3', roleId: 'analyst' },
      { name: '通信員', color: '#dda0dd', roleId: 'communicator' }
    ];
    const info = hintInfo[hintId] || { name: '不明', color: '#ffffff', roleId: 'unknown' };

    const numHintId = Number(hintId);

    // ★ 即座にローディング表示（体感速度向上）
    setCurrentHint({
      title: 'ヒント #' + (numHintId + 1),
      message: '🔄 読み込み中...',
      color: info.color
    });
    setShowHintModal(true);
    
    // 複数のソースから値を取得（優先順位: ref > state > localStorage）
    let currentTeamNumber = teamNumberRef.current || teamNumber;
    let currentPlayerId = myPlayerIdRef.current || myPlayerId;
    
    // localStorageからも試行
    if (!currentTeamNumber || !currentPlayerId) {
      try {
        const saved = localStorage.getItem('cyberEscapeGameState');
        if (saved) {
          const state = JSON.parse(saved);
          if (!currentTeamNumber && state.teamNumber) currentTeamNumber = state.teamNumber;
          if (!currentPlayerId && state.myPlayerId) currentPlayerId = state.myPlayerId;
        }
      } catch (e) {}
    }
    
    // ★ 優先順位: ref > state > localStorage > DB
    // RefからroleとteamSizeを取得（これが最も信頼できる）
    let currentRole = roleRef.current || role;
    let currentTeamSize = teamSizeRef.current || teamSize;

    console.log('collectHint: teamNumber=' + currentTeamNumber + ', roleRef=' + (currentRole ? currentRole.id : 'null') + ', teamSizeRef=' + currentTeamSize);

    // ローカル状態を先に取得
    let teamHintsFound = [...(hintsFoundRef.current || []).map(Number)];
    let teamHintsUnlocked = [...(hintsUnlockedRef.current || []).map(Number)];

    if (!currentTeamNumber) {
      console.error('collectHint: teamNumberが空です');
      setCurrentHint({
        title: 'エラー',
        message: '❌ チーム情報が見つかりません。\nロビーからやり直してください。',
        color: '#ff6b6b'
      });
      return;
    }

    // ★ ファストパス: ローカル状態が有効なら即座に表示（DB待ちをスキップ）
    const localRole = currentRole;
    let localTeamSize = currentTeamSize;
    let dbTeamSize = currentTeamSize;
    
    // ローカルに有効なroleとteamSize（5以外）があれば、DB呼び出しをスキップ
    if (localRole && localTeamSize && localTeamSize !== 5) {
      console.log('collectHint: ファストパス（DB待ちスキップ） teamSize=' + localTeamSize);
      dbTeamSize = localTeamSize;
    } else {
      // ローカル状態が不十分な場合のみDBから取得
      console.log('collectHint: DB取得が必要 (localTeamSize=' + localTeamSize + ')');
      try {
        const teamForSize = await supabase.getTeam(currentTeamNumber);
        if (teamForSize && teamForSize.data) {
          dbTeamSize = teamForSize.data.maxMembers || teamForSize.size || currentTeamSize;
          localTeamSize = dbTeamSize;
          console.log('collectHint: DB teamSize=' + dbTeamSize);
          if (dbTeamSize !== teamSizeRef.current) {
            updateTeamSize(dbTeamSize);
          }
        }
      } catch (e) { console.error('collectHint: teamSize fetch error:', e); }
    }

    if (localRole && localTeamSize) {
      const fastPerms = getHintPermissions(localTeamSize, localRole.id);
      const fastCanSee = fastPerms.includes(numHintId);

      // ヒント内容取得（ファストパス用）
      const fastGetContent = (hId) => {
        const contents = {
          2: { 0: ['▲は1番目'], 1: ['★は3番目'], 2: ['●は■より後ろ'], 3: ['数列：3, 4, 5, ?, ?', '■は2番目'], 4: ['◆は最後', '?は0と4'] },
          3: { 0: ['1番目は3角の形'], 1: ['4角の形は2つある'], 2: ['数列：3, 4, 5, 0, 4'], 3: ['この数列が順番を決める'], 4: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'] },
          4: { 0: ['答えは5つの形の列'], 1: ['角の数で順番が決まる'], 2: ['3番目は5角'], 3: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'], 4: ['数列完成：3,4,5,0,4', '4番目は0'] },
          5: { 0: ['全員の情報を統合せよ'], 1: ['角の数が順番の法則'], 2: ['青=▲ 緑=■', '黄=★ 赤=● 紫=◆'], 3: ['数列：3,4,5,0,4'], 4: ['4角の形は2つある', '■が先、◆が後'] },
        };
        return contents[localTeamSize]?.[hId] || ['ヒントなし'];
      };

      const fastGetWhoCanSee = (hId) => {
        const perms = {
          2: { leader: [0,1], decoder: [2,3,4] },
          3: { leader: [0,1], decoder: [2,3], investigator: [4] },
          4: { leader: [0], decoder: [1,2], investigator: [3], analyst: [4] },
          5: { leader: [0], decoder: [1], investigator: [2], analyst: [3], communicator: [4] },
        };
        const names = { leader: 'リーダー', decoder: '解読員', investigator: '調査員', analyst: '分析員', communicator: '通信員' };
        const sizePerms = perms[localTeamSize] || {};
        const whoList = [];
        for (const r in sizePerms) {
          if (sizePerms[r].includes(hId)) whoList.push(names[r]);
        }
        return whoList.join('、') || '不明';
      };

      // 既に開封済み（ファストパス）
      if (teamHintsFound.includes(numHintId)) {
        if (fastCanSee) {
          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（開封済み）',
            message: fastGetContent(numHintId).join('\n'),
            color: info.color
          });
        } else {
          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（開封済み）',
            message: '🔒 このヒントは「' + fastGetWhoCanSee(numHintId) + '」が見れます。\n\nチームメンバーに内容を確認してもらいましょう！',
            color: '#666666'
          });
        }
        return;  // ファストパス終了
      }

      // 反射ゲームクリア済み（ファストパス）
      if (teamHintsUnlocked.includes(numHintId)) {
        if (fastCanSee) {
          // 即座に開封
          const newHintsFound = [...new Set([...teamHintsFound, numHintId])];
          setHintsFound(newHintsFound);
          hintsFoundRef.current = newHintsFound;

          // 非同期でSupabase保存
          (async () => {
            try {
              const team = await supabase.getTeam(currentTeamNumber);
              if (team) {
                const data = team.data || {};
                const localFound = (hintsFoundRef.current || []).map(Number);
                const serverFound = (data.hintsFound || []).map(Number);
                data.hintsFound = [...new Set([...localFound, ...serverFound, numHintId])];
                const localUnlocked = (hintsUnlockedRef.current || []).map(Number);
                const serverUnlocked = (data.hintsUnlocked || []).map(Number);
                data.hintsUnlocked = [...new Set([...localUnlocked, ...serverUnlocked])];
                await supabase.updateTeam(currentTeamNumber, data);
              }
            } catch (e) { console.error('saveHintFound error:', e); }
          })();

          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（開封完了！）',
            message: fastGetContent(numHintId).join('\n'),
            color: info.color
          });
        } else {
          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（解除済み）',
            message: '🔓 反射ゲームはクリア済みです！\n\n📢 「' + fastGetWhoCanSee(numHintId) + '」がこのオブジェクトでEキーを押すと開封できます。\n\nチームメンバーに開封を依頼しましょう！',
            color: '#ffaa00'
          });
        }
        return;  // ファストパス終了
      }
    }

    // ★ 通常パス: Supabaseから同期（新規ヒントの反射ゲーム開始時など）
    // 注意: DBからのチームサイズ取得は既に上で行っているのでここでは省略
    currentTeamSize = dbTeamSize;  // DBから取得した値を使用
    try {
      const team = await supabase.getTeam(currentTeamNumber);
      if (team && team.data) {
        // roleRefがない場合のみDBから取得（フォールバック）
        if (!currentRole && team.data.members) {
          const myEntry = team.data.members.find(m => String(m.oderId) === String(currentPlayerId));
          if (myEntry && myEntry.roleIndex !== undefined) {
            const roles = getRolesForTeamSize(currentTeamSize);
            currentRole = roles[myEntry.roleIndex];
            console.log('collectHint: DBフォールバック roleIndex=' + myEntry.roleIndex);
          }
        }
        if (team.data.hintsFound) {
          const sf = team.data.hintsFound.map(Number);
          teamHintsFound = [...new Set([...teamHintsFound, ...sf])];
          setHintsFound(teamHintsFound);
          hintsFoundRef.current = teamHintsFound;
        }
        if (team.data.hintsUnlocked) {
          const su = team.data.hintsUnlocked.map(Number);
          teamHintsUnlocked = [...new Set([...teamHintsUnlocked, ...su])];
          setHintsUnlocked(teamHintsUnlocked);
          hintsUnlockedRef.current = teamHintsUnlocked;
        }
      }
    } catch (e) { console.error('syncHints error:', e); }

    // roleRefから取得した値で権限チェック（DBではなくReact状態を信頼）
    const myPermissions = currentRole ? getHintPermissions(currentTeamSize, currentRole.id) : [];
    const canSeeHint = myPermissions.includes(numHintId);

    console.log('collectHint: teamSize=' + currentTeamSize + ', role=' + (currentRole ? currentRole.id : 'null') + ', hintId=' + numHintId + ', perms=' + JSON.stringify(myPermissions));

    // ヒントの内容を取得
    const getHintContent = (hId) => {
      const contents = {
        2: { 0: ['▲は1番目'], 1: ['★は3番目'], 2: ['●は■より後ろ'], 3: ['数列：3, 4, 5, ?, ?', '■は2番目'], 4: ['◆は最後', '?は0と4'] },
        3: { 0: ['1番目は3角の形'], 1: ['4角の形は2つある'], 2: ['数列：3, 4, 5, 0, 4'], 3: ['この数列が順番を決める'], 4: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'] },
        4: { 0: ['答えは5つの形の列'], 1: ['角の数で順番が決まる'], 2: ['3番目は5角'], 3: ['青=▲ 緑=■ 黄=★', '赤=● 紫=◆'], 4: ['数列完成：3,4,5,0,4', '4番目は0'] },
        5: { 0: ['全員の情報を統合せよ'], 1: ['角の数が順番の法則'], 2: ['青=▲ 緑=■', '黄=★ 赤=● 紫=◆'], 3: ['数列：3,4,5,0,4'], 4: ['4角の形は2つある', '■が先、◆が後'] },
      };
      return contents[currentTeamSize]?.[hId] || ['ヒントなし'];
    };

    // 誰が見れるヒントか表示用
    const getWhoCanSee = (hId) => {
      const numId = Number(hId);  // 数値型に統一
      const perms = {
        2: { leader: [0,1], decoder: [2,3,4] },
        3: { leader: [0,1], decoder: [2,3], investigator: [4] },
        4: { leader: [0], decoder: [1,2], investigator: [3], analyst: [4] },
        5: { leader: [0], decoder: [1], investigator: [2], analyst: [3], communicator: [4] },
      };
      const names = { leader: 'リーダー', decoder: '解読員', investigator: '調査員', analyst: '分析員', communicator: '通信員' };
      const sizePerms = perms[currentTeamSize] || {};
      const whoList = [];
      for (const r in sizePerms) {
        if (sizePerms[r].includes(numId)) whoList.push(names[r]);
      }
      return whoList.join('、') || '不明';
    };

    // ===== ステージ3: 既にヒントが開封済み =====
    if (teamHintsFound.includes(numHintId)) {
      if (canSeeHint) {
        setCurrentHint({
          title: 'ヒント #' + (numHintId + 1) + '（開封済み）',
          message: getHintContent(numHintId).join('\n'),
          color: info.color
        });
      } else {
        setCurrentHint({
          title: 'ヒント #' + (numHintId + 1) + '（開封済み）',
          message: '🔒 このヒントは「' + getWhoCanSee(hintId) + '」が見れます。\n\nチームメンバーに内容を確認してもらいましょう！',
          color: '#666666'
        });
      }
      setShowHintModal(true);
      return;
    }

    // ===== ステージ2: 反射ゲームクリア済み =====
    if (teamHintsUnlocked.includes(numHintId)) {
      if (canSeeHint) {
        const confirmed = true; // 確認なしで直接開封
        if (confirmed) {
          // ローカル状態を即座に更新
          const newHintsFound = [...new Set([...teamHintsFound, numHintId])];
          setHintsFound(newHintsFound);
          hintsFoundRef.current = newHintsFound;

          // Supabaseに非同期で保存（全ヒントデータをマージ）
          (async () => {
            try {
              const team = await supabase.getTeam(teamNumber);
              if (team) {
                const data = team.data || {};
                // hintsFoundをマージ
                const localFound = (hintsFoundRef.current || []).map(Number);
                const serverFound = (data.hintsFound || []).map(Number);
                data.hintsFound = [...new Set([...localFound, ...serverFound, numHintId])];
                // hintsUnlockedも保持
                const localUnlocked = (hintsUnlockedRef.current || []).map(Number);
                const serverUnlocked = (data.hintsUnlocked || []).map(Number);
                data.hintsUnlocked = [...new Set([...localUnlocked, ...serverUnlocked])];
                await supabase.updateTeam(teamNumber, data);
              }
            } catch (e) { console.error('saveHintFound error:', e); }
          })();

          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（開封完了！）',
            message: getHintContent(numHintId).join('\n'),
            color: info.color
          });
        } else {
          setCurrentHint({
            title: 'ヒント #' + (numHintId + 1) + '（解除済み）',
            message: '⏳ 開封を保留しました。\n\n再度Eキーを押すと開封できます。',
            color: '#ffaa00'
          });
        }
      } else {
        setCurrentHint({
          title: 'ヒント #' + (numHintId + 1) + '（解除済み）',
          message: '🔓 反射ゲームはクリア済みです！\n\n📢 「' + getWhoCanSee(hintId) + '」がこのオブジェクトでEキーを押すと開封できます。\n\nチームメンバーに開封を依頼しましょう！',
          color: '#ffaa00'
        });
      }
      setShowHintModal(true);
      return;
    }

    // ===== ステージ1: 反射ゲーム開始 =====
    const difficulty = getDifficultyFromTeamSize(teamSize);
    const whoSees = getWhoCanSee(hintId);

    const onComplete = async () => {
      const numId = Number(hintId);

      // ローカル状態を即座に更新
      const newUnlocked = [...new Set([...(hintsUnlockedRef.current || []).map(Number), numId])];
      hintsUnlockedRef.current = newUnlocked;
      setHintsUnlocked(newUnlocked);

      // 権限がある人なら直接ヒントを開封
      if (canSeeHint) {
        // hintsFoundに追加
        const newHintsFound = [...new Set([...(hintsFoundRef.current || []).map(Number), numId])];
        setHintsFound(newHintsFound);
        hintsFoundRef.current = newHintsFound;

        // Supabaseに保存（hintsFound + hintsUnlocked両方）
        try {
          const team = await supabase.getTeam(teamNumber);
          if (team) {
            const data = team.data || {};
            const localUnlocked = (hintsUnlockedRef.current || []).map(Number);
            const serverUnlocked = (data.hintsUnlocked || []).map(Number);
            data.hintsUnlocked = [...new Set([...localUnlocked, ...serverUnlocked, numId])];
            const localFound = (hintsFoundRef.current || []).map(Number);
            const serverFound = (data.hintsFound || []).map(Number);
            data.hintsFound = [...new Set([...localFound, ...serverFound, numId])];
            await supabase.updateTeam(teamNumber, data);
          }
        } catch (e) { console.error('saveHint error:', e); }

        // 直接ヒント内容を表示
        setCurrentHint({
          title: 'ヒント #' + (numHintId + 1) + '（解除成功！）',
          message: '🔓 反射ゲームクリア！\n\n' + getHintContent(numHintId).join('\n'),
          color: info.color
        });
      } else {
        // 権限がない人は解除のみ
        try {
          const team = await supabase.getTeam(teamNumber);
          if (team) {
            const data = team.data || {};
            const localUnlocked = (hintsUnlockedRef.current || []).map(Number);
            const serverUnlocked = (data.hintsUnlocked || []).map(Number);
            data.hintsUnlocked = [...new Set([...localUnlocked, ...serverUnlocked, numId])];
            const localFound = (hintsFoundRef.current || []).map(Number);
            const serverFound = (data.hintsFound || []).map(Number);
            data.hintsFound = [...new Set([...localFound, ...serverFound])];
            await supabase.updateTeam(teamNumber, data);
          }
        } catch (e) { console.error('saveHintUnlocked error:', e); }

        setCurrentHint({
          title: 'ヒント #' + (numHintId + 1) + '（解除成功！）',
          message: '🔓 反射ゲームクリア！\n\n📢 「' + whoSees + '」がこのオブジェクトでEキーを押すとヒントを開封できます。\n\n権限のあるチームメンバーに開封を依頼しましょう！',
          color: '#00ff88'
        });
      }
      setShowHintModal(true);
    };

    const onClose = () => {
      const existing = document.getElementById('reflex-game-container');
      if (existing) existing.remove();
    };

    // 反射ゲーム開始前にローディングモーダルを閉じる
    setShowHintModal(false);
    startReflexGame(difficulty, 'hint', onComplete, onClose);
  };

  // パズル回答をチェック
  const checkPuzzleAnswer = async () => {
    // 正解: ▲ ■ ★ ● ◆（三角、四角、星、丸、ひし形）
    const correctAnswers = ['▲', '■', '★', '●', '◆'];
    const userAnswers = puzzleInput.map(s => s.trim());

    // 全て入力されているかチェック
    if (userAnswers.some(a => a === '')) {
      setPuzzleError('全ての欄に形を入力してください');
      return;
    }

    // 正解チェック
    const isCorrect = userAnswers.every((ans, idx) => ans === correctAnswers[idx]);

    if (isCorrect) {
      // ★ 即座にローディング表示＆キー入力を無効化
      isEscapingRef.current = true;
      setIsEscaping(true);
      setShowFinalInputModal(false);
      // refを即座に更新（重複実行防止）
      gameCompletedRef.current = true;
      screenRef.current = 'escaping';  // 先にrefも更新
      setGameCompleted(true);
      clearGameState();  // ゲーム完了時にlocalStorageをクリア
      const finalTime = getTeamSettings(teamSize).timeLimit - timeLeft;
      setCompletionTime(finalTime);

      // Supabaseに完了を記録（非同期で実行、画面遷移を待たない）
      try {
        const team = await supabase.getTeam(teamNumber);
        if (team) {
          const data = team.data || {};
          data.completed = true;
          data.completionTime = finalTime;
          await supabase.updateTeam(teamNumber, data);
        }
      } catch (e) { console.error('saveCompletion error:', e); }

      // ランキングを取得
      try {
        const allTeams = await supabase.getAllTeams();
        const completedTeams = allTeams
          .filter(t => t.data && t.data.completed)
          .map(t => ({
            name: t.name,
            code: t.code,
            time: t.data.completionTime,
            size: t.data.maxMembers || t.size || 5
          }))
          .sort((a, b) => a.time - b.time);
        setRankings(completedTeams);
      } catch (e) { console.error('fetchRankings error:', e); }

      // 脱出アニメーション画面へ遷移
      screenRef.current = 'escaping';
      setScreen('escaping');
    } else {
      setPuzzleError('不正解です。ヒントを確認して再度入力してください。');
    }
  };

  // hintsFoundRefを常に最新に保つ
  useEffect(() => {
    hintsFoundRef.current = hintsFound;
  }, [hintsFound]);

  // hintsUnlockedRefを常に最新に保つ
  useEffect(() => {
    hintsUnlockedRef.current = hintsUnlocked;
  }, [hintsUnlocked]);

  // タイマー
  useEffect(() => {
    if (timerStarted && timeLeft > 0 && screen === 'game') {
      const timer = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            setScreen('complete');
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [timerStarted, timeLeft, screen]);

  // インタラクション処理用のRef（クロージャ問題を回避）
  const nearbyObjectRef = useRef(null);
  useEffect(() => { nearbyObjectRef.current = nearbyObject; }, [nearbyObject]);

  // インタラクション処理（ボタンとキーの両方から呼び出し可能）
  const handleInteraction = () => {
    const currentNearbyObject = nearbyObjectRef.current;
    const currentRole = roleRef.current;
    if (currentNearbyObject) {
      if (currentNearbyObject.type === 'hint') {
        collectHint(currentNearbyObject.id);
      } else if (currentNearbyObject.type === 'puzzle') {
        // 中央コンソールはリーダーのみ操作可能
        if (currentRole?.id !== 'leader') {
          alert('中央コンソールはリーダーのみ操作できます。\nリーダーに操作を依頼してください。');
          return;
        }
        // シンボルをシャッフルする関数
        const shuffleSymbols = () => {
          const symbols = ['▲', '■', '★', '●', '◆'];
          for (let i = symbols.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
          }
          setShuffledSymbols(symbols);
        };

        // 反射ゲームをクリア済みなら直接最終パズルへ
        if (consoleReflexCleared) {
          setPuzzleInput(['', '', '', '', '']);
          setPuzzleError('');
          shuffleSymbols();
          setShowFinalInputModal(true);
        } else {
          // 反射ゲームを開始
          const difficulty = getDifficultyFromTeamSize(teamSizeRef.current || teamSize);
          const onComplete = function() {
            setConsoleReflexCleared(true);
            setPuzzleInput(['', '', '', '', '']);
            setPuzzleError('');
            shuffleSymbols();
            setShowFinalInputModal(true);
          };
          const onClose = function() {};
          startReflexGame(difficulty, 'final', onComplete, onClose);
        }
      }
    }
  };

  // キー入力でインタラクション
  useEffect(() => {
    const onKeyDown = function(e) {
      if (e.key.toLowerCase() === 'e') {
        handleInteraction();
      }
    };
    
    window.addEventListener('keydown', onKeyDown);
    return function() { window.removeEventListener('keydown', onKeyDown); };
  }, []);

  // Three.js シーン
  useEffect(() => {
    if (screen !== 'game' || !mountRef.current) return;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000510, 10, 50);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // ライティング
    const ambientLight = new THREE.AmbientLight(0x4a5f8f, 0.4);
    scene.add(ambientLight);

    const topLight = new THREE.PointLight(0xadd8e6, 2, 30);
    topLight.position.set(0, 15, 0);
    topLight.castShadow = true;
    topLight.shadow.mapSize.width = 2048;
    topLight.shadow.mapSize.height = 2048;
    scene.add(topLight);

    const blueLight1 = new THREE.PointLight(0x00ffff, 1.5, 20);
    blueLight1.position.set(-10, 3, -10);
    scene.add(blueLight1);

    const blueLight2 = new THREE.PointLight(0x00ffff, 1.5, 20);
    blueLight2.position.set(10, 3, -10);
    scene.add(blueLight2);

    const purpleLight = new THREE.PointLight(0xff00ff, 1.2, 15);
    purpleLight.position.set(0, 2, -15);
    scene.add(purpleLight);

    const greenLight = new THREE.PointLight(0x00ff88, 1, 12);
    greenLight.position.set(-8, 2, 0);
    scene.add(greenLight);

    // 床
    const floorGeometry = new THREE.CircleGeometry(18, 64);
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a3550,
      metalness: 0.3,
      roughness: 0.7
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // 魔法陣
    const circleGeometry = new THREE.RingGeometry(8, 8.2, 64);
    const circleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide
    });
    const magicCircle = new THREE.Mesh(circleGeometry, circleMaterial);
    magicCircle.rotation.x = -Math.PI / 2;
    magicCircle.position.y = 0.02;
    scene.add(magicCircle);

    const innerCircle = new THREE.Mesh(
      new THREE.RingGeometry(5, 5.15, 64),
      circleMaterial
    );
    innerCircle.rotation.x = -Math.PI / 2;
    innerCircle.position.y = 0.03;
    scene.add(innerCircle);

    // 六芒星
    const starPoints = [];
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
      starPoints.push(new THREE.Vector3(
        Math.cos(angle) * 6,
        0.04,
        Math.sin(angle) * 6
      ));
    }
    for (let i = 0; i < 6; i++) {
      const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        starPoints[i],
        starPoints[(i + 2) % 6]
      ]);
      const lineMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.7
      });
      const line = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(line);
    }

    // 壁
    const wallSegments = 32;
    for (let i = 0; i < wallSegments; i++) {
      const angle = (i / wallSegments) * Math.PI * 2;
      const wallGeometry = new THREE.BoxGeometry(2, 12, 0.5);
      const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a2e,
        metalness: 0.2,
        roughness: 0.8
      });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.x = Math.cos(angle) * 17;
      wall.position.z = Math.sin(angle) * 17;
      wall.position.y = 6;
      wall.rotation.y = -angle;
      wall.castShadow = true;
      wall.receiveShadow = true;
      scene.add(wall);
    }

    // 木目テクスチャ生成
    const createWoodTexture = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createLinearGradient(0, 0, 512, 0);
      gradient.addColorStop(0, '#3a2515');
      gradient.addColorStop(0.5, '#4a3020');
      gradient.addColorStop(1, '#3a2515');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      for (let i = 0; i < 80; i++) {
        ctx.strokeStyle = `rgba(${30 + Math.random() * 20}, ${20 + Math.random() * 15}, ${10 + Math.random() * 10}, ${0.4 + Math.random() * 0.3})`;
        ctx.lineWidth = 0.5 + Math.random() * 2;
        ctx.beginPath();
        const y = Math.random() * 512;
        const variance = Math.random() * 40 - 20;
        ctx.moveTo(0, y);
        ctx.bezierCurveTo(170, y + variance, 340, y - variance, 512, y);
        ctx.stroke();
      }
      
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const radius = 10 + Math.random() * 20;
        const knotGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        knotGradient.addColorStop(0, 'rgba(20, 15, 10, 0.6)');
        knotGradient.addColorStop(1, 'rgba(20, 15, 10, 0)');
        ctx.fillStyle = knotGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    };

    const createBookTexture = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      const colors = ['#2a4a7a', '#4a2a6a', '#5a3a2a', '#2a5a4a', '#6a4a2a', '#3a3a5a'];
      const baseColor = colors[Math.floor(Math.random() * colors.length)];
      ctx.fillStyle = baseColor;
      ctx.fillRect(0, 0, 128, 256);
      
      ctx.strokeStyle = 'rgba(200, 180, 120, 0.5)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
        ctx.beginPath();
        ctx.moveTo(10, 60 + i * 30);
        ctx.lineTo(118, 60 + i * 30);
        ctx.stroke();
      }
      
      const edgeGradient = ctx.createLinearGradient(0, 0, 20, 0);
      edgeGradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
      edgeGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = edgeGradient;
      ctx.fillRect(0, 0, 20, 256);
      
      return new THREE.CanvasTexture(canvas);
    };

    const woodTexture = createWoodTexture();
    woodTexture.repeat.set(1, 2);

    // 本棚
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * Math.PI * 2;
      
      const shelfGeometry = new THREE.BoxGeometry(3.5, 8, 0.2);
      const shelfMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture.clone(),
        color: 0x5a4530,
        metalness: 0.05,
        roughness: 0.95
      });
      const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
      shelf.position.x = Math.cos(angle) * 15.2;
      shelf.position.z = Math.sin(angle) * 15.2;
      shelf.position.y = 4;
      shelf.rotation.y = -angle;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      scene.add(shelf);

      const sideGeometry = new THREE.BoxGeometry(0.15, 8, 0.6);
      const sideMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture.clone(),
        color: 0x4a3520,
        metalness: 0.05,
        roughness: 0.95
      });
      
      const leftSide = new THREE.Mesh(sideGeometry, sideMaterial);
      leftSide.position.x = shelf.position.x + Math.cos(angle - Math.PI / 2) * 1.75;
      leftSide.position.z = shelf.position.z + Math.sin(angle - Math.PI / 2) * 1.75;
      leftSide.position.y = 4;
      leftSide.rotation.y = -angle;
      leftSide.castShadow = true;
      scene.add(leftSide);
      
      const rightSide = new THREE.Mesh(sideGeometry, sideMaterial);
      rightSide.position.x = shelf.position.x + Math.cos(angle + Math.PI / 2) * 1.75;
      rightSide.position.z = shelf.position.z + Math.sin(angle + Math.PI / 2) * 1.75;
      rightSide.position.y = 4;
      rightSide.rotation.y = -angle;
      rightSide.castShadow = true;
      scene.add(rightSide);

      for (let level = 0; level < 5; level++) {
        const shelfPlateGeometry = new THREE.BoxGeometry(3.3, 0.08, 0.55);
        const plateTexture = woodTexture.clone();
        plateTexture.repeat.set(2, 1);
        const shelfPlateMaterial = new THREE.MeshStandardMaterial({
          map: plateTexture,
          color: 0x5a4a35,
          metalness: 0.05,
          roughness: 0.9
        });
        const shelfPlate = new THREE.Mesh(shelfPlateGeometry, shelfPlateMaterial);
        shelfPlate.position.x = shelf.position.x;
        shelfPlate.position.z = shelf.position.z;
        shelfPlate.position.y = 0.8 + level * 1.6;
        shelfPlate.rotation.y = -angle;
        shelfPlate.castShadow = true;
        shelfPlate.receiveShadow = true;
        scene.add(shelfPlate);
      }

      // 本を配置
      for (let j = 0; j < 5; j++) {
        const booksPerShelf = 12; // 各棚に12冊
        const shelfY = 1.1 + j * 1.6;
        
        for (let k = 0; k < booksPerShelf; k++) {
          const bookTexture = createBookTexture();
          const bookWidth = 0.12;
          const bookHeight = 0.5 + Math.random() * 0.2;
          const bookDepth = 0.35;
          const bookGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth);
          const bookMaterial = new THREE.MeshStandardMaterial({
            map: bookTexture,
            emissive: Math.random() > 0.85 ? 0x001133 : 0x000000,
            emissiveIntensity: 0.3,
            metalness: 0.1,
            roughness: 0.85
          });
          const book = new THREE.Mesh(bookGeometry, bookMaterial);
          
          // 本を横に並べる（-1.4 から 1.4 の範囲）
          const xOffset = (k - (booksPerShelf - 1) / 2) * 0.24;
          
          // 本棚のローカル座標系で配置してから回転
          // 本棚は angle の方向を向いている
          // 本は棚板の上、背板の手前に配置
          const localX = xOffset;  // 横方向
          const localZ = 0.15;     // 手前方向（中心に向かって）
          
          // 回転行列を適用
          const cosA = Math.cos(angle);
          const sinA = Math.sin(angle);
          
          // 本棚の中心位置
          const shelfCenterX = Math.cos(angle) * 15.2;
          const shelfCenterZ = Math.sin(angle) * 15.2;
          
          // ローカル座標をワールド座標に変換
          // 本棚のローカルX軸は接線方向、ローカルZ軸は法線方向（中心向き）
          book.position.x = shelfCenterX - sinA * localX - cosA * localZ;
          book.position.z = shelfCenterZ + cosA * localX - sinA * localZ;
          book.position.y = shelfY;
          book.rotation.y = -angle;
          book.castShadow = true;
          book.receiveShadow = true;
          scene.add(book);
        }
      }
    }

    // ヒントクリスタル（各役割の色でカラフルに）
    const hintColors = [
      { x: -8, z: -8, color: '#ffd700', name: 'リーダー', height: 0.8 },      // 金
      { x: 8, z: -8, color: '#ff6b6b', name: '解読員', height: 0.8 },        // 赤
      { x: -10, z: 0, color: '#4ecdc4', name: '調査員', height: 0.8 },       // 青緑
      { x: 10, z: 0, color: '#95e1d3', name: '分析員', height: 0.8 },        // 薄緑
      { x: 0, z: -12, color: '#dda0dd', name: '通信員', height: 0.8 }        // 紫
    ];

    hintObjectsRef.current = [];

    hintColors.forEach((pos, idx) => {
      const crystalColor = pos.color;
      
      const pedestalGeometry = new THREE.CylinderGeometry(0.8, 1, 0.5, 8);
      const pedestalMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a3550,
        metalness: 0.7,
        roughness: 0.3
      });
      const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
      pedestal.position.set(pos.x, 0.25, pos.z);
      pedestal.castShadow = true;
      pedestal.receiveShadow = true;
      scene.add(pedestal);

      const crystalGeometry = new THREE.OctahedronGeometry(0.5, 0);
      const crystalMaterial = new THREE.MeshStandardMaterial({
        color: crystalColor,
        emissive: crystalColor,
        emissiveIntensity: 1,
        metalness: 0.8,
        roughness: 0.2,
        transparent: true,
        opacity: 0.9
      });
      const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
      crystal.position.set(pos.x, pos.height, pos.z);
      crystal.castShadow = true;
      crystal.userData = { 
        type: 'hint', 
        id: idx, 
        name: pos.name,
        baseY: pos.height 
      };
      scene.add(crystal);
      
      hintObjectsRef.current.push({
        mesh: crystal,
        position: { x: pos.x, z: pos.z },
        type: 'hint',
        id: idx
      });

      const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: crystalColor,
        transparent: true,
        opacity: 0.2
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.position.copy(crystal.position);
      glow.userData = { isGlow: true, crystalId: idx };
      scene.add(glow);

      const crystalLight = new THREE.PointLight(crystalColor, 1, 8);
      crystalLight.position.copy(crystal.position);
      scene.add(crystalLight);

      const runeGeometry = new THREE.RingGeometry(1, 1.1, 32);
      const runeMaterial = new THREE.MeshBasicMaterial({
        color: crystalColor,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      const rune = new THREE.Mesh(runeGeometry, runeMaterial);
      rune.rotation.x = -Math.PI / 2;
      rune.position.set(pos.x, 0.01, pos.z);
      rune.userData = { isRune: true, crystalId: idx };
      scene.add(rune);
    });

    // 中央コンソール - 美しいTorusKnotオブジェクト
    const consoleBaseGeometry = new THREE.CylinderGeometry(2, 2.5, 0.4, 32);
    const consoleBaseMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a2540,
      metalness: 0.9,
      roughness: 0.1
    });
    const consoleBase = new THREE.Mesh(consoleBaseGeometry, consoleBaseMaterial);
    consoleBase.position.set(0, 0.2, 0);
    consoleBase.castShadow = true;
    consoleBase.receiveShadow = true;
    scene.add(consoleBase);

    // 台座の装飾リング
    const baseRingGeometry = new THREE.TorusGeometry(2.2, 0.08, 16, 64);
    const baseRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.8,
      metalness: 1.0,
      roughness: 0.0
    });
    const baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
    baseRing.position.set(0, 0.4, 0);
    baseRing.rotation.x = Math.PI / 2;
    scene.add(baseRing);

    // メインのTorusKnotオブジェクト
    const torusKnotGeometry = new THREE.TorusKnotGeometry(1, 0.35, 128, 32, 2, 3);
    const torusKnotMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 1.0,
      roughness: 0.0,
      envMapIntensity: 1.5
    });
    const torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);
    torusKnot.position.set(0, 2.2, 0);
    torusKnot.castShadow = true;
    torusKnot.userData = { type: 'puzzle', id: 0, isTorusKnot: true };
    scene.add(torusKnot);

    consoleRef.current = {
      position: { x: 0, z: 0 },
      type: 'puzzle',
      id: 0
    };

    // TorusKnotの周りの発光エフェクト
    const glowSphereGeometry = new THREE.SphereGeometry(1.8, 32, 32);
    const glowSphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
      side: THREE.BackSide
    });
    const glowSphere = new THREE.Mesh(glowSphereGeometry, glowSphereMaterial);
    glowSphere.position.set(0, 2.2, 0);
    glowSphere.userData = { isConsoleGlow: true };
    scene.add(glowSphere);

    // 浮遊する外側リング（3つ）
    const orbitRingGeometry = new THREE.TorusGeometry(1.8, 0.03, 16, 64);
    const orbitRingMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1.2,
      metalness: 1.0,
      roughness: 0.0,
      transparent: true,
      opacity: 0.9
    });
    
    const orbitRing1 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial);
    orbitRing1.position.set(0, 2.2, 0);
    orbitRing1.userData = { isOrbitRing: true, id: 0 };
    scene.add(orbitRing1);

    const orbitRing2 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial.clone());
    orbitRing2.position.set(0, 2.2, 0);
    orbitRing2.userData = { isOrbitRing: true, id: 1 };
    scene.add(orbitRing2);

    const orbitRing3 = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial.clone());
    orbitRing3.position.set(0, 2.2, 0);
    orbitRing3.userData = { isOrbitRing: true, id: 2 };
    scene.add(orbitRing3);

    // 中心から放射する光のビーム（柱）
    const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6, 8);
    const beamMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.3
    });
    const beam = new THREE.Mesh(beamGeometry, beamMaterial);
    beam.position.set(0, 2.2, 0);
    scene.add(beam);

    // 環境マップ風のキューブマップ（疑似反射用）
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
    cubeRenderTarget.texture.type = THREE.HalfFloatType;
    
    // ポイントライト（TorusKnotを照らす）
    const torusLight = new THREE.PointLight(0x00ffff, 2, 10);
    torusLight.position.set(0, 2.2, 0);
    scene.add(torusLight);

    const torusLight2 = new THREE.PointLight(0xff00ff, 1, 8);
    torusLight2.position.set(2, 3, 2);
    scene.add(torusLight2);

    const torusLight3 = new THREE.PointLight(0xffff00, 1, 8);
    torusLight3.position.set(-2, 3, -2);
    scene.add(torusLight3);

    // パーティクル
    const particleCount = 200;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 1] = Math.random() * 10;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      velocities.push({
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02
      });
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.1,
      transparent: true,
      opacity: 0.6
    });
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // イベントリスナー
    const handleKeyDown = (e) => {
      keysRef.current[e.key.toLowerCase()] = true;
      if (e.key === 'Escape') {
        setShowMessage(false);
        setShowHintModal(false);
        setShowFinalInputModal(false);
        setShowVoxelPuzzle(false);
      }
    };

    const handleKeyUp = (e) => {
      keysRef.current[e.key.toLowerCase()] = false;
    };

    const handleMouseDown = (e) => {
      isMouseDownRef.current = true;
      lastMouseRef.current = { x: e.clientX, y: e.clientY };
      e.preventDefault();
    };

    const handleMouseUp = () => {
      isMouseDownRef.current = false;
    };

    const handleMouseMove = (e) => {
      if (isMouseDownRef.current) {
        const deltaX = e.clientX - lastMouseRef.current.x;
        const deltaY = e.clientY - lastMouseRef.current.y;
        
        const sensitivity = 0.005;
        playerRef.current.rotation -= deltaX * sensitivity;
        playerRef.current.rotationX -= deltaY * sensitivity;
        playerRef.current.rotationX = Math.max(-1.5, Math.min(1.5, playerRef.current.rotationX));
        
        lastMouseRef.current = { x: e.clientX, y: e.clientY };
      }
    };

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    renderer.domElement.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('resize', handleResize);

    // アニメーションループ
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // パーティクルアニメーション
      const positions = particles.geometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;
        positions[i * 3 + 2] += velocities[i].z;

        if (Math.abs(positions[i * 3]) > 20) velocities[i].x *= -1;
        if (positions[i * 3 + 1] > 15 || positions[i * 3 + 1] < 0) velocities[i].y *= -1;
        if (Math.abs(positions[i * 3 + 2]) > 20) velocities[i].z *= -1;
      }
      particles.geometry.attributes.position.needsUpdate = true;

      // オブジェクトアニメーション
      scene.traverse((object) => {
        if (object.userData.type === 'hint' && object.userData.baseY) {
          object.position.y = object.userData.baseY + Math.sin(time * 2 + object.userData.id) * 0.2;
          object.rotation.y = time * 0.5;
        }
        if (object.userData.isGlow) {
          const scale = 1 + Math.sin(time * 3 + object.userData.crystalId) * 0.1;
          object.scale.set(scale, scale, scale);
        }
        if (object.userData.isRune) {
          object.rotation.z = time * 0.3 * (object.userData.crystalId % 2 === 0 ? 1 : -1);
        }
        // TorusKnotの回転アニメーション
        if (object.userData.isTorusKnot) {
          object.rotation.y = time * 0.3;
          object.rotation.x = time * 0.2;
        }
        // コンソールのグローエフェクト
        if (object.userData.isConsoleGlow) {
          const scale = 1 + Math.sin(time * 2) * 0.15;
          object.scale.set(scale, scale, scale);
          object.material.opacity = 0.08 + Math.sin(time * 3) * 0.05;
        }
        // オービットリングの回転
        if (object.userData.isOrbitRing) {
          const id = object.userData.id;
          if (id === 0) {
            object.rotation.x = time * 0.8;
            object.rotation.y = time * 0.3;
          } else if (id === 1) {
            object.rotation.x = Math.PI / 3;
            object.rotation.y = time * 0.6;
            object.rotation.z = time * 0.4;
          } else {
            object.rotation.x = -Math.PI / 3;
            object.rotation.y = -time * 0.5;
            object.rotation.z = time * 0.3;
          }
        }
      });

      // プレイヤー移動（脱出処理中は移動を停止）
      if (isEscapingRef.current) {
        // 脱出処理中は移動を停止し、アニメーション画面への遷移を優先
        renderer.render(scene, camera);
        return;
      }
      
      const speed = 0.15;
      const player = playerRef.current;
      const keys = keysRef.current;
      const mobileKeys = window.mobileKeys || {};

      if (keys['w'] || mobileKeys.w) {
        player.x -= Math.sin(player.rotation) * speed;
        player.z -= Math.cos(player.rotation) * speed;
      }
      if (keys['s'] || mobileKeys.s) {
        player.x += Math.sin(player.rotation) * speed;
        player.z += Math.cos(player.rotation) * speed;
      }
      if (keys['a'] || mobileKeys.a) {
        player.x -= Math.cos(player.rotation) * speed;
        player.z += Math.sin(player.rotation) * speed;
      }
      if (keys['d'] || mobileKeys.d) {
        player.x += Math.cos(player.rotation) * speed;
        player.z -= Math.sin(player.rotation) * speed;
      }

      // 境界制限
      const distFromCenter = Math.sqrt(player.x * player.x + player.z * player.z);
      if (distFromCenter > 15) {
        const angle = Math.atan2(player.z, player.x);
        player.x = Math.cos(angle) * 15;
        player.z = Math.sin(angle) * 15;
      }

      // 近くのオブジェクト検出
      let nearestObject = null;
      let nearestDist = 3;

      hintObjectsRef.current.forEach(hint => {
        const dx = player.x - hint.position.x;
        const dz = player.z - hint.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestObject = hint;
        }
      });

      if (consoleRef.current) {
        const dx = player.x - consoleRef.current.position.x;
        const dz = player.z - consoleRef.current.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestObject = consoleRef.current;
        }
      }

      setNearbyObject(nearestObject);

      camera.position.x = player.x;
      camera.position.z = player.z;
      camera.rotation.order = 'YXZ';
      camera.rotation.y = player.rotation;
      camera.rotation.x = player.rotationX;

      // 他プレイヤーのアバター更新
      const lerpFactor = 0.15;
      const roleColors = {
        0: '#ffd700', 1: '#ff6b6b', 2: '#4ecdc4', 3: '#95e1d3', 4: '#dda0dd'
      };

      Object.entries(otherPlayersRef.current).forEach(([oderId, playerData]) => {
        // 補間処理
        playerData.current.x += (playerData.target.x - playerData.current.x) * lerpFactor;
        playerData.current.z += (playerData.target.z - playerData.current.z) * lerpFactor;
        let rotDiff = playerData.target.rotation - playerData.current.rotation;
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerData.current.rotation += rotDiff * lerpFactor;

        let avatar = avatarMeshesRef.current[oderId];

        // アバターがなければ作成
        if (!avatar) {
          const color = roleColors[playerData.roleIndex] || '#ffffff';
          avatar = createMinecraftAvatar(color);
          avatar.userData.oderId = oderId;
          avatar.userData.roleName = playerData.roleName;
          scene.add(avatar);
          avatarMeshesRef.current[oderId] = avatar;

          // 役割名ラベルを追加
          if (playerData.roleName) {
            const label = createRoleLabel(playerData.roleName, color);
            avatar.add(label);
            avatar.userData.label = label;
          }
        }

        // 位置・向き更新
        avatar.position.x = playerData.current.x;
        avatar.position.z = playerData.current.z;
        avatar.rotation.y = playerData.current.rotation + Math.PI;

        // 歩行アニメーション
        const isMoving =
          Math.abs(playerData.target.x - playerData.current.x) > 0.01 ||
          Math.abs(playerData.target.z - playerData.current.z) > 0.01;

        if (isMoving) {
          const walkCycle = time * 8;
          avatar.userData.leftArm.rotation.x = Math.sin(walkCycle) * 0.5;
          avatar.userData.rightArm.rotation.x = -Math.sin(walkCycle) * 0.5;
          avatar.userData.leftLeg.rotation.x = -Math.sin(walkCycle) * 0.4;
          avatar.userData.rightLeg.rotation.x = Math.sin(walkCycle) * 0.4;
        } else {
          avatar.userData.leftArm.rotation.x = 0;
          avatar.userData.rightArm.rotation.x = 0;
          avatar.userData.leftLeg.rotation.x = 0;
          avatar.userData.rightLeg.rotation.x = 0;
        }
      });

      // 切断したプレイヤーのアバター削除
      Object.keys(avatarMeshesRef.current).forEach(oderId => {
        if (!otherPlayersRef.current[oderId]) {
          const avatar = avatarMeshesRef.current[oderId];
          scene.remove(avatar);
          delete avatarMeshesRef.current[oderId];
        }
      });

      renderer.render(scene, camera);
    };

    animate();

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      renderer.domElement.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('resize', handleResize);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [screen]);

  // メッセージ自動非表示
  useEffect(() => {
    if (showMessage && screen === 'game') {
      const timer = setTimeout(() => setShowMessage(false), 30000);
      return () => clearTimeout(timer);
    }
  }, [showMessage, screen]);

  // ゲーム画面から離れる時にThree.jsを明示的にクリーンアップ
  useEffect(() => {
    if (screen !== 'game' && rendererRef.current) {
      console.log('Cleaning up Three.js renderer');
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
        animationIdRef.current = null;
      }
      try {
        rendererRef.current.dispose();
        rendererRef.current.forceContextLoss();
        if (rendererRef.current.domElement && rendererRef.current.domElement.parentNode) {
          rendererRef.current.domElement.parentNode.removeChild(rendererRef.current.domElement);
        }
      } catch (e) { console.error('Three.js cleanup error:', e); }
      rendererRef.current = null;
      sceneRef.current = null;
      cameraRef.current = null;
    }
  }, [screen]);

  // 脱出演出画面（3秒後に自動で完了画面へ）
  useEffect(() => {
    if (screen === 'escaping') {
      const timer = setTimeout(() => setScreen('complete'), 3000);
      return () => clearTimeout(timer);
    }
  }, [screen]);

  // ロビーデータ定期更新
  useEffect(() => {
    if (screen === 'lobby') {
      const interval = setInterval(fetchLobbyData, 1000);
      return () => clearInterval(interval);
    }
  }, [screen, teamNumber, myPlayerId, selectedRole]);

  // ゲーム中の位置送信（500ms間隔）
  useEffect(() => {
    if (screen !== 'game' || !myPlayerId) return;
    const interval = setInterval(updateMyPosition, 500);
    return () => clearInterval(interval);
  }, [screen, myPlayerId, teamNumber]);

  // ゲーム中の他プレイヤー位置受信・ゲーム完了検知（500ms間隔）
  useEffect(() => {
    if (screen !== 'game' || !myPlayerId) return;
    const interval = setInterval(fetchOtherPlayers, 500);
    return () => clearInterval(interval);
  }, [screen, myPlayerId, teamNumber]);

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // エントリー画面
  if (screen === 'entry') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-8 rounded-lg shadow-2xl max-w-md w-full border border-cyan-500">
          <h1 className="text-4xl font-bold text-cyan-400 mb-2 text-center">サイバー研究所</h1>
          <h2 className="text-2xl text-cyan-300 mb-8 text-center">脱出ゲーム</h2>
          
          <div className="mb-6">
            <div className="flex gap-2 mb-4">
              <button
                onClick={() => setJoinMode('create')}
                className={`flex-1 py-2 rounded transition ${joinMode === 'create' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                チーム作成
              </button>
              <button
                onClick={() => setJoinMode('join')}
                className={`flex-1 py-2 rounded transition ${joinMode === 'join' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-300'}`}
              >
                チーム参加
              </button>
            </div>

            {joinMode === 'create' ? (
              <>
                <label className="block text-cyan-300 mb-2">チーム名</label>
                <input
                  type="text"
                  value={teamName}
                  onChange={(e) => setTeamName(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleCreateTeam()}
                  className="w-full px-4 py-3 bg-gray-700 text-white rounded border border-cyan-500 focus:outline-none focus:border-cyan-400 mb-4"
                  placeholder="チーム名を入力"
                />
                <label className="block text-cyan-300 mb-2">チーム人数</label>
                <div className="grid grid-cols-4 gap-2 mb-4">
                  {[2, 3, 4, 5].map(num => (
                    <button
                      key={num}
                      onClick={() => updateTeamSize(num)}
                      className={`py-3 rounded-lg text-xl font-bold transition ${
                        teamSize === num 
                          ? 'bg-cyan-600 text-white ring-2 ring-cyan-400' 
                          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                      }`}
                    >
                      {num}人
                    </button>
                  ))}
                </div>
                <button
                  onClick={handleCreateTeam}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  チーム作成
                </button>
              </>
            ) : (
              <>
                <label className="block text-cyan-300 mb-2">チーム番号（4桁）</label>
                <input
                  type="number"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  value={teamNumber}
                  onChange={function(e) { setTeamNumber(e.target.value.replace(/\D/g, '').slice(0, 4)); }}
                  onKeyDown={function(e) { if (e.key === 'Enter') handleJoinTeam(); }}
                  className="w-full px-4 py-3 bg-gray-700 text-white text-center text-3xl tracking-widest font-mono rounded border border-cyan-500 focus:outline-none focus:border-cyan-400 mb-4"
                  placeholder="1234"
                  maxLength="4"
                  autoComplete="off"
                />
                <button
                  onClick={handleJoinTeam}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  チーム参加
                </button>
              </>
            )}
          </div>

          <div className="mt-6 text-cyan-300 text-sm space-y-1">
            <p>• 制限時間: 15分</p>
            <p>• チーム人数: 2〜5名</p>
            <p>• 操作: WASD移動、マウス視点</p>
          </div>
          
          {/* 管理者ログイン */}
          <div className="mt-8 pt-6 border-t border-gray-700">
            <p className="text-gray-500 text-xs mb-2 text-center">管理者用</p>
            <div className="flex gap-2">
              <input
                type="password"
                value={adminPassword}
                onChange={(e) => setAdminPassword(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && enterAdminScreen()}
                className="flex-1 px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:border-gray-500 text-sm"
                placeholder="管理者パスワード"
              />
              <button
                onClick={enterAdminScreen}
                className="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-300 rounded transition text-sm"
              >
                管理画面
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // 管理画面
  if (screen === 'admin') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-slate-900 to-gray-900 p-4 overflow-auto">
        <div className="max-w-6xl mx-auto">
          {/* ヘッダー */}
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-3xl font-bold text-cyan-400">🎮 管理画面</h1>
            <div className="flex gap-4">
              <button
                onClick={fetchAllTeams}
                className="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded transition"
              >
                🔄 更新
              </button>
              <button
                onClick={resetAllTeams}
                className="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded transition"
              >
                🗑️ 全削除
              </button>
              <button
                onClick={exitAdminScreen}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded transition"
              >
                ← 戻る
              </button>
            </div>
          </div>
          
          {/* 統計サマリー */}
          <div className="grid grid-cols-4 gap-4 mb-6">
            <div className="bg-gray-800 p-4 rounded-lg border border-cyan-500">
              <p className="text-gray-400 text-sm">総チーム数</p>
              <p className="text-3xl font-bold text-white">{allTeams.length}</p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-green-500">
              <p className="text-gray-400 text-sm">クリア済み</p>
              <p className="text-3xl font-bold text-green-400">
                {allTeams.filter(t => t.completed).length}
              </p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-yellow-500">
              <p className="text-gray-400 text-sm">プレイ中</p>
              <p className="text-3xl font-bold text-yellow-400">
                {allTeams.filter(t => t.startTime && !t.completed && getTeamTimeLeft(t) > 0).length}
              </p>
            </div>
            <div className="bg-gray-800 p-4 rounded-lg border border-red-500">
              <p className="text-gray-400 text-sm">時間切れ</p>
              <p className="text-3xl font-bold text-red-400">
                {allTeams.filter(t => t.startTime && !t.completed && getTeamTimeLeft(t) <= 0).length}
              </p>
            </div>
          </div>
          
          {/* ランキング（クリア済みチーム） */}
          {allTeams.filter(t => t.completed).length > 0 && (
            <div className="mb-6">
              <h2 className="text-xl font-bold text-cyan-400 mb-3">🏆 ランキング</h2>
              <div className="bg-gray-800 rounded-lg border border-cyan-500 overflow-hidden">
                <table className="w-full">
                  <thead className="bg-gray-700">
                    <tr>
                      <th className="px-4 py-3 text-left text-cyan-300">順位</th>
                      <th className="px-4 py-3 text-left text-cyan-300">チーム名</th>
                      <th className="px-4 py-3 text-left text-cyan-300">クリアタイム</th>
                      <th className="px-4 py-3 text-left text-cyan-300">メンバー数</th>
                    </tr>
                  </thead>
                  <tbody>
                    {allTeams.filter(t => t.completed).map((team, idx) => (
                      <tr key={team.number} className={idx % 2 === 0 ? 'bg-gray-800' : 'bg-gray-750'}>
                        <td className="px-4 py-3">
                          <span className={`text-2xl ${idx === 0 ? 'text-yellow-400' : idx === 1 ? 'text-gray-300' : idx === 2 ? 'text-amber-600' : 'text-gray-500'}`}>
                            {idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : `${idx + 1}位`}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-white font-bold">{team.name}</td>
                        <td className="px-4 py-3 text-green-400 font-mono text-lg">
                          {formatTime(team.completionTime || 0)}
                        </td>
                        <td className="px-4 py-3 text-gray-300">{team.members?.length || 0}名</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
          
          {/* 全チーム一覧 */}
          <h2 className="text-xl font-bold text-cyan-400 mb-3">📋 全チーム状況</h2>
          <div className="grid gap-4">
            {allTeams.length === 0 ? (
              <div className="bg-gray-800 p-8 rounded-lg border border-gray-700 text-center">
                <p className="text-gray-400">まだチームが作成されていません</p>
              </div>
            ) : (
              allTeams.map(team => {
                const timeRemaining = getTeamTimeLeft(team);
                const isPlaying = team.startTime && !team.completed && timeRemaining > 0;
                const isTimeout = team.startTime && !team.completed && timeRemaining <= 0;
                
                return (
                  <div
                    key={team.number}
                    className={`bg-gray-800 p-4 rounded-lg border ${
                      team.completed ? 'border-green-500' : isTimeout ? 'border-red-500' : isPlaying ? 'border-yellow-500' : 'border-gray-600'
                    }`}
                  >
                    <div className="flex justify-between items-start">
                      <div>
                        <div className="flex items-center gap-3">
                          <h3 className="text-lg font-bold text-white">{team.name}</h3>
                          <span className="text-gray-500 text-sm">#{team.number}</span>
                          {team.completed && (
                            <span className="px-2 py-1 bg-green-500 bg-opacity-20 text-green-400 text-xs rounded">
                              ✓ クリア
                            </span>
                          )}
                          {isTimeout && (
                            <span className="px-2 py-1 bg-red-500 bg-opacity-20 text-red-400 text-xs rounded">
                              時間切れ
                            </span>
                          )}
                          {isPlaying && (
                            <span className="px-2 py-1 bg-yellow-500 bg-opacity-20 text-yellow-400 text-xs rounded animate-pulse">
                              プレイ中
                            </span>
                          )}
                          {!team.startTime && (
                            <span className="px-2 py-1 bg-gray-500 bg-opacity-20 text-gray-400 text-xs rounded">
                              待機中
                            </span>
                          )}
                        </div>
                        <p className="text-gray-400 text-sm mt-1">
                          メンバー: {team.members?.length || 0}名
                        </p>
                      </div>
                      
                      <div className="text-right">
                        {team.completed ? (
                          <div>
                            <p className="text-gray-400 text-xs">クリアタイム</p>
                            <p className="text-2xl font-bold text-green-400 font-mono">
                              {formatTime(team.completionTime || 0)}
                            </p>
                          </div>
                        ) : team.startTime ? (
                          <div>
                            <p className="text-gray-400 text-xs">残り時間</p>
                            <p className={`text-2xl font-bold font-mono ${timeRemaining < 60 ? 'text-red-400' : 'text-cyan-400'}`}>
                              {formatTime(timeRemaining)}
                            </p>
                          </div>
                        ) : null}
                      </div>
                    </div>
                    
                    {/* 進捗バー */}
                    <div className="mt-3">
                      <div className="flex justify-between text-xs text-gray-400 mb-1">
                        <span>ヒント進捗</span>
                        <span>{team.hintsFound?.length || 0} / {getTeamSettings(team.maxMembers || 5).hintsRequired}</span>
                      </div>
                      <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-gradient-to-r from-cyan-500 to-green-500 transition-all duration-500"
                          style={{ width: `${((team.hintsFound?.length || 0) / getTeamSettings(team.maxMembers || 5).hintsRequired) * 100}%` }}
                        />
                      </div>
                      
                      {/* ヒント詳細（チーム人数に応じた数を表示） */}
                      <div className="flex gap-2 mt-2">
                        {Array.from({ length: getTeamSettings(team.maxMembers || 5).hintsRequired }, (_, idx) => (
                          <div
                            key={idx}
                            className={`w-8 h-8 rounded flex items-center justify-center text-xs ${
                              team.hintsFound?.includes(idx)
                                ? 'bg-green-500 bg-opacity-30 text-green-400 border border-green-500'
                                : 'bg-gray-700 text-gray-500 border border-gray-600'
                            }`}
                            title={`ヒント${idx + 1}`}
                          >
                            {team.hintsFound?.includes(idx) ? '✓' : idx + 1}
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })
            )}
          </div>
          
          {/* フッター情報 */}
          <div className="mt-6 text-center text-gray-500 text-sm">
            <p>5秒ごとに自動更新 | パスワード: admin123</p>
          </div>
        </div>
      </div>
    );
  }

  // 待機室（チーム番号共有用）
  if (screen === 'waiting') {
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-8 rounded-lg shadow-2xl max-w-md w-full border border-cyan-500">
          <h1 className="text-3xl font-bold text-cyan-400 mb-6 text-center">待機室</h1>
          
          <div className="bg-gray-900 p-6 rounded-lg mb-6 border border-cyan-500">
            <div className="text-center mb-4">
              <p className="text-cyan-300 mb-2">チーム名</p>
              <p className="text-2xl font-bold text-white">{teamName}</p>
            </div>
            <div className="text-center mb-4">
              <p className="text-cyan-300 mb-1">チーム人数</p>
              <p className="text-xl font-bold text-cyan-400">{teamSize}人</p>
            </div>
            <div className="text-center">
              <p className="text-cyan-300 mb-3">チーム番号（これを伝えてね！）</p>
              <p className="text-7xl font-bold text-cyan-400 tracking-widest font-mono">{teamNumber}</p>
            </div>
          </div>

          <button
            onClick={enterLobby}
            className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition mb-4"
          >
            ロビーに入る →
          </button>

          <button
            onClick={() => setScreen('entry')}
            className="w-full bg-gray-700 hover:bg-gray-600 text-white py-2 rounded transition"
          >
            ← 戻る
          </button>
        </div>
      </div>
    );
  }

  // ロビー画面（役割選択）
  if (screen === 'lobby') {
    const memberCount = lobbyData?.members?.length || 0;
    const maxMembers = lobbyData?.maxMembers || teamSize;
    const availableRoles = getRolesForTeamSize(maxMembers);
    const allMembersJoined = memberCount >= maxMembers;
    
    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
        <div className="bg-gray-800 bg-opacity-90 p-6 rounded-lg shadow-2xl max-w-2xl w-full border border-cyan-500">
          {/* ヘッダー */}
          <div className="flex justify-between items-center mb-4">
            <div>
              <h1 className="text-2xl font-bold text-cyan-400">{teamName}</h1>
              <p className="text-gray-400 text-sm">#{teamNumber}</p>
            </div>
            <div className="text-right">
              <p className="text-gray-400 text-sm">参加者</p>
              <p className={`text-2xl font-bold ${allMembersJoined ? 'text-green-400' : 'text-white'}`}>
                {memberCount}/{maxMembers}名
              </p>
            </div>
          </div>
          
          {/* メンバー待ち or タイマー */}
          {!allMembersJoined ? (
            <div className="text-center p-6 bg-gray-900 rounded-lg mb-6 border border-yellow-500">
              <p className="text-yellow-400 text-xl mb-2">メンバー待機中...</p>
              <p className="text-gray-400">全員揃ったら役割を選べます</p>
            </div>
          ) : (
            <div className={`text-center p-4 rounded-lg mb-6 ${roleSelectTimer <= 10 ? 'bg-red-900 border-red-500' : 'bg-gray-900 border-cyan-500'} border`}>
              <p className="text-gray-400 text-sm mb-1">役割決めタイム</p>
              <p className={`text-4xl font-bold font-mono ${roleSelectTimer <= 10 ? 'text-red-400 animate-pulse' : 'text-cyan-400'}`}>
                {roleSelectTimer}秒
              </p>
              <p className="text-gray-500 text-xs mt-1">
                時間切れで未選択の人は自動割り当て
              </p>
            </div>
          )}
          
          {/* 役割選択カード */}
          <div className="mb-6">
            <p className="text-cyan-300 mb-3 text-center">
              {allMembersJoined ? '👥 チームで相談して役割を決めてください' : '👥 メンバーが揃うまでお待ちください'}
            </p>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {availableRoles.map((r, idx) => {
                const takenBy = lobbyData?.members?.find(m => m.roleIndex === idx);
                const isMySelection = selectedRole === idx;
                const isTaken = takenBy && !isMySelection;
                
                return (
                  <div
                    key={r.id}
                    className={`p-4 rounded-lg border-2 transition-all ${
                      isMySelection 
                        ? 'border-green-500 bg-green-900 bg-opacity-30' 
                        : isTaken 
                          ? 'border-gray-600 bg-gray-800 opacity-60'
                          : 'border-gray-600 bg-gray-800 hover:border-cyan-400'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <div 
                        className="w-12 h-12 rounded-full flex items-center justify-center text-2xl"
                        style={{ backgroundColor: r.color + '40', border: `2px solid ${r.color}` }}
                      >
                        {r.icon}
                      </div>
                      <div className="flex-1">
                        <h3 className="font-bold text-white">{r.name}</h3>
                        <p className="text-gray-400 text-xs">Role {idx + 1}</p>
                      </div>
                      
                      {isMySelection ? (
                        <span className="px-3 py-1 bg-green-600 text-white text-sm rounded">
                          ✓ 選択中
                        </span>
                      ) : isTaken ? (
                        <span className="px-3 py-1 bg-gray-600 text-gray-300 text-sm rounded">
                          選択済み
                        </span>
                      ) : !allMembersJoined ? (
                        <span className="px-3 py-1 bg-gray-700 text-gray-500 text-sm rounded">
                          待機中
                        </span>
                      ) : selectedRole === null ? (
                        <button
                          onClick={() => selectRole(idx)}
                          className="px-3 py-1 bg-cyan-600 hover:bg-cyan-500 text-white text-sm rounded transition"
                        >
                          選択
                        </button>
                      ) : (
                        <span className="px-3 py-1 bg-gray-700 text-gray-400 text-sm rounded">
                          ---
                        </span>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* メンバー状況 */}
          <div className="bg-gray-900 p-4 rounded-lg mb-4">
            <p className="text-gray-400 text-sm mb-2">メンバー状況</p>
            <div className="flex flex-wrap gap-2">
              {lobbyData?.members?.map((member, idx) => {
                const memberRoles = getRolesForTeamSize(maxMembers);
                return (
                  <div 
                    key={member.oderId || idx}
                    className={`px-3 py-1 rounded-full text-sm ${
                      member.oderId === myPlayerId 
                        ? 'bg-cyan-600 text-white' 
                        : member.roleIndex !== undefined
                          ? 'bg-green-600 bg-opacity-50 text-green-300'
                          : 'bg-gray-700 text-gray-400'
                    }`}
                  >
                    {member.oderId === myPlayerId ? '自分' : `Player ${idx + 1}`}
                    {member.roleIndex !== undefined && ` (${memberRoles[member.roleIndex]?.icon})`}
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* アクションボタン */}
          <div className="flex gap-3">
            <button
              onClick={exitLobby}
              className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition"
            >
              ← 戻る
            </button>
            <button
              onClick={handleStartGame}
              disabled={selectedRole === null || !allMembersJoined}
              className={`flex-1 font-bold py-3 rounded transition ${
                selectedRole !== null && allMembersJoined
                  ? 'bg-green-600 hover:bg-green-500 text-white'
                  : 'bg-gray-600 text-gray-400 cursor-not-allowed'
              }`}
            >
              {!allMembersJoined ? 'メンバー待ち...' : selectedRole !== null ? 'ゲーム開始！' : '役割を選んでください'}
            </button>
          </div>
          
          {/* テスト用ボタン */}
          {!allMembersJoined && (
            <button
              onClick={forceFullTeam}
              className="w-full mt-3 bg-yellow-600 hover:bg-yellow-500 text-white py-2 rounded text-sm"
            >
              🧪 テスト：ダミーメンバー追加（1人でテスト）
            </button>
          )}
        </div>
      </div>
    );
  }

  // ゲーム画面
  if (screen === 'game') {
    return (
      <div className="relative w-full h-screen overflow-hidden" style={{zIndex: 1}}>
        <div ref={mountRef} className="w-full h-full" />
        
        {/* 脱出処理中のローディングオーバーレイ */}
        {isEscaping && (
          <div className="absolute inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center z-50">
            <div className="text-6xl mb-6 animate-bounce">🎉</div>
            <h1 className="text-4xl font-bold text-green-400 mb-4 animate-pulse">正解！</h1>
            <p className="text-cyan-300 text-xl">脱出準備中...</p>
            <div className="mt-6 w-16 h-16 border-4 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
          </div>
        )}
        
        {/* タイマー */}
        <div className="absolute top-4 right-4 bg-black bg-opacity-70 px-6 py-3 rounded border border-cyan-500">
          <div className={`text-2xl font-bold ${timeLeft < 60 ? 'text-red-400 animate-pulse' : 'text-cyan-400'}`}>
            {formatTime(timeLeft)}
          </div>
        </div>

        {/* チーム情報 */}
        <div className="absolute top-4 left-4 bg-black bg-opacity-70 px-6 py-3 rounded border border-cyan-500">
          <div className="text-cyan-400 font-bold">{teamName}</div>
          <div className="text-cyan-300 text-sm">#{teamNumber}</div>
          {assignedRoles.length > 0 && (
            <div className="mt-2 text-sm">
              {assignedRoles.map((r, i) => (
                <span key={r.id} className="inline-block px-2 py-1 rounded mr-1 mb-1" style={{ backgroundColor: r.color + '40', color: r.color }}>
                  {r.name}
                </span>
              ))}
            </div>
          )}
        </div>

        {/* ヒント進捗 */}
        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 px-4 py-2 rounded border border-cyan-500">
          <div className="text-cyan-300 text-sm">ヒント: {hintsFound.length} / {getTeamSettings(teamSize).hintsRequired}</div>
        </div>

        {/* インタラクションUI */}
        {nearbyObject && !showHintModal && !showFinalInputModal && (
          <div className="absolute bottom-24 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 px-6 py-3 rounded border-2 border-cyan-400 animate-pulse">
            <p className="text-cyan-400 text-lg font-bold text-center">
              {nearbyObject.type === 'hint' ? (
                <>
                  <span className="text-2xl">E</span> を押して調べる
                  {hintsFound.includes(nearbyObject.id) && <span className="ml-2 text-green-400">（取得済み）</span>}
                </>
              ) : (
                <>
                  <span className="text-2xl">E</span> を押してコンソールを操作
                </>
              )}
            </p>
          </div>
        )}

        {/* 役割メッセージ（電光掲示板スタイル） */}
        {showMessage && role && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-50">
            <div className="max-w-3xl w-full mx-4">
              <div className="bg-gray-900 border-2 rounded-lg p-8 shadow-2xl" style={{ borderColor: role.color }}>
                <div className="flex items-center justify-center gap-3 mb-2">
                  <span className="text-4xl">{role.icon}</span>
                  <h2 className="text-3xl font-bold" style={{ color: role.color }}>
                    {role.name}
                  </h2>
                </div>
                <p className="text-gray-400 text-center mb-6">シークレットメッセージ - メモを取ってください！</p>
                
                {/* 電光掲示板エリア */}
                <div className="bg-black rounded-lg p-4 mb-6 overflow-hidden border border-gray-700">
                  <style>
                    {`
                      @keyframes scrollText {
                        0% { transform: translateX(100%); }
                        100% { transform: translateX(-100%); }
                      }
                    `}
                  </style>
                  <div className="space-y-4">
                    {getSecretMessage(teamSize, role.id).map((line, idx) => (
                      <div key={idx} className="relative h-8 overflow-hidden border-b border-gray-800">
                        <div 
                          style={{ 
                            color: role.color,
                            textShadow: `0 0 10px ${role.color}`,
                            animation: `scrollText 8s linear infinite`,
                            animationDelay: `${idx * 0.5}s`,
                            whiteSpace: 'nowrap',
                            position: 'absolute',
                            fontSize: '1.25rem',
                            fontFamily: 'monospace',
                            fontWeight: 'bold'
                          }}
                        >
                          ● {line} ● {line} ● {line} ●
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                
                <p className="text-gray-500 text-sm text-center mb-4">※ 一人では絶対に解けません。仲間と情報を共有しよう！</p>
                
                <button
                  onClick={() => setShowMessage(false)}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  3D空間に入る →
                </button>
              </div>
            </div>
          </div>
        )}

        {/* ヒントモーダル */}
        {showHintModal && currentHint && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 z-50">
            <div className="max-w-lg w-full mx-4">
              <div className="bg-gray-900 border-2 rounded-lg p-6 shadow-2xl" style={{ borderColor: currentHint.color }}>
                <h2 className="text-2xl font-bold mb-4 text-center" style={{ color: currentHint.color }}>
                  {currentHint.title}
                </h2>
                <div className="bg-black p-4 rounded mb-4">
                  <pre className="text-lg font-mono whitespace-pre-wrap" style={{ color: currentHint.color }}>
                    {currentHint.message}
                  </pre>
                </div>
                <button
                  onClick={() => setShowHintModal(false)}
                  className="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded transition"
                >
                  閉じる (ESC)
                </button>
              </div>
            </div>
          </div>
        )}

        {/* 最終パズル入力画面（ドラッグ&ドロップ） */}
        {showFinalInputModal && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-50">
            <div className="max-w-lg w-full mx-4">
              <div className="bg-gray-900 border-2 border-green-500 rounded-lg p-6 shadow-2xl">
                <h2 className="text-2xl font-bold mb-4 text-center text-green-400">
                  🔓 最終認証 - 形を並べる
                </h2>

                <p className="text-gray-300 text-center mb-4">
                  下の形をドラッグして、正しい順番に並べてください。
                </p>

                {/* ドロップゾーン（回答欄） */}
                <div className="bg-gray-800 p-4 rounded mb-4">
                  <p className="text-gray-400 text-sm mb-2 text-center">回答欄（ここに形をドロップ）</p>
                  <div className="flex justify-center gap-2">
                    {puzzleInput.map((val, idx) => (
                      <div
                        key={idx}
                        className={`w-14 h-14 flex items-center justify-center text-3xl bg-gray-700 border-2 rounded cursor-pointer select-none ${val ? 'border-green-400' : 'border-cyan-500 border-dashed'}`}
                        onDragOver={(e) => e.preventDefault()}
                        onDrop={(e) => {
                          e.preventDefault();
                          const symbol = e.dataTransfer.getData('text/plain');
                          if (symbol) {
                            const newInput = [...puzzleInput];
                            newInput[idx] = symbol;
                            setPuzzleInput(newInput);
                          }
                        }}
                        onClick={() => {
                          if (val) {
                            const newInput = [...puzzleInput];
                            newInput[idx] = '';
                            setPuzzleInput(newInput);
                          }
                        }}
                        title={val ? 'クリックで削除' : `${idx + 1}番目`}
                      >
                        {val || <span className="text-gray-500 text-lg">{idx + 1}</span>}
                      </div>
                    ))}
                  </div>
                  <p className="text-gray-500 text-xs text-center mt-2">※配置した形をクリックすると削除できます</p>
                </div>

                {/* ドラッグ元（形の選択肢） */}
                <div className="bg-gray-800 p-4 rounded mb-4">
                  <p className="text-gray-400 text-sm mb-2 text-center">形をドラッグしてください</p>
                  <div className="flex justify-center gap-3">
                    {shuffledSymbols.map((symbol) => (
                      <div
                        key={symbol}
                        draggable
                        onDragStart={(e) => {
                          e.dataTransfer.setData('text/plain', symbol);
                          e.dataTransfer.effectAllowed = 'copy';
                        }}
                        className="w-12 h-12 flex items-center justify-center text-3xl bg-cyan-700 hover:bg-cyan-600 border-2 border-cyan-400 rounded cursor-grab active:cursor-grabbing select-none transition"
                        title={symbol === '▲' ? '三角' : symbol === '■' ? '四角' : symbol === '★' ? '星' : symbol === '●' ? '丸' : 'ひし形'}
                      >
                        {symbol}
                      </div>
                    ))}
                  </div>
                  <p className="text-gray-500 text-xs text-center mt-2">三角=▲ 四角=■ 星=★ 丸=● ひし形=◆</p>
                </div>

                {puzzleError && (
                  <p className="text-red-400 text-center mb-4">{puzzleError}</p>
                )}

                <div className="flex gap-4">
                  <button
                    onClick={() => {
                      setShowFinalInputModal(false);
                      setPuzzleError('');
                      setPuzzleInput(['', '', '', '', '']);
                    }}
                    className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition"
                  >
                    キャンセル
                  </button>
                  <button
                    onClick={() => {
                      setPuzzleInput(['', '', '', '', '']);
                      setPuzzleError('');
                    }}
                    className="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded transition"
                  >
                    リセット
                  </button>
                  <button
                    onClick={checkPuzzleAnswer}
                    className="flex-1 bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded transition"
                  >
                    認証する
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* 反射神経ゲームはDOM直接操作で表示（startReflexGame関数） */}

        {/* 操作説明（PC向け） */}
        <div className="absolute bottom-4 left-4 bg-black bg-opacity-70 px-4 py-2 rounded text-cyan-300 text-sm hidden md:block">
          <p>WASD: 移動 | マウスドラッグ: 視点回転 | E: 調べる</p>
        </div>

        {/* スマホ用操作ボタン */}
        <div className="absolute bottom-4 left-4 md:hidden flex flex-col gap-2">
          <div className="flex justify-center">
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.w = true; }}
              onTouchEnd={function() { window.mobileKeys.w = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >↑</button>
          </div>
          <div className="flex gap-2">
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.a = true; }}
              onTouchEnd={function() { window.mobileKeys.a = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >←</button>
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.s = true; }}
              onTouchEnd={function() { window.mobileKeys.s = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >↓</button>
            <button 
              onTouchStart={function() { window.mobileKeys = window.mobileKeys || {}; window.mobileKeys.d = true; }}
              onTouchEnd={function() { window.mobileKeys.d = false; }}
              className="w-14 h-14 bg-cyan-600 bg-opacity-70 rounded-full text-white text-2xl font-bold active:bg-cyan-400"
            >→</button>
          </div>
        </div>

        {/* インタラクションボタン（近くにオブジェクトがある時表示） */}
        {nearbyObject && (
          <button
            onClick={handleInteraction}
            className="absolute bottom-4 right-4 bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-4 px-8 rounded-lg text-xl shadow-lg animate-pulse"
          >
            🔍 調べる (E)
          </button>
        )}

        <style jsx>{`
          @keyframes marquee {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
          }
          .animate-marquee {
            animation: marquee 30s linear infinite;
          }
        `}</style>
      </div>
    );
  }

  if (screen === 'escaping') {
    return (
      <div className="fixed inset-0 bg-black flex flex-col items-center justify-center overflow-hidden" style={{zIndex: 9999}}>
        {/* 脱出アニメーション */}
        <div className="relative w-full h-2/3 overflow-hidden">
          {/* 研究所の背景 */}
          <div className="absolute inset-0 bg-gradient-to-t from-gray-900 via-blue-900 to-purple-900">
            {/* 建物シルエット */}
            <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-96 h-64 bg-gray-800 rounded-t-lg border-t-4 border-cyan-500">
              <div className="absolute top-4 left-1/2 transform -translate-x-1/2 text-cyan-400 text-xl font-bold">
                🏢 サイバー研究所
              </div>
              {/* 窓 */}
              <div className="absolute top-16 left-8 w-12 h-8 bg-cyan-900 rounded"></div>
              <div className="absolute top-16 right-8 w-12 h-8 bg-cyan-900 rounded"></div>
              <div className="absolute top-32 left-8 w-12 h-8 bg-cyan-900 rounded"></div>
              <div className="absolute top-32 right-8 w-12 h-8 bg-cyan-900 rounded"></div>
              {/* ドア（開いている） */}
              <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-20 h-24 bg-green-500 rounded-t-lg flex items-center justify-center">
                <span className="text-4xl">🚪</span>
              </div>
            </div>

            {/* アバターたちが走り出す */}
            <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 flex space-x-4 animate-bounce">
              {[
                { emoji: '🧑‍💼', color: 'text-yellow-400', name: 'リーダー' },
                { emoji: '🧑‍🔬', color: 'text-red-400', name: '解読員' },
                { emoji: '🕵️', color: 'text-cyan-400', name: '調査員' },
                { emoji: '📊', color: 'text-green-400', name: '分析員' },
                { emoji: '📡', color: 'text-purple-400', name: '通信員' }
              ].slice(0, teamSize).map((member, idx) => (
                <div
                  key={idx}
                  className="flex flex-col items-center transform transition-all duration-1000"
                  style={{
                    animation: `escapeRun 2s ease-out ${idx * 0.2}s forwards`
                  }}
                >
                  <span className="text-4xl">{member.emoji}</span>
                  <span className={`text-xs ${member.color} font-bold`}>{member.name}</span>
                </div>
              ))}
            </div>
          </div>

          {/* 成功メッセージ */}
          <div className="absolute top-8 left-1/2 transform -translate-x-1/2 text-center">
            <div className="text-6xl mb-4 animate-pulse">🎉</div>
            <h1 className="text-4xl font-bold text-green-400 animate-pulse">脱出成功！</h1>
          </div>
        </div>

        {/* クリアタイム表示 */}
        <div className="text-center mt-8">
          <p className="text-gray-400 text-lg mb-2">クリアタイム</p>
          <p className="text-5xl font-bold text-green-400 font-mono">
            {formatTime(completionTime || 0)}
          </p>
        </div>

        {/* 結果を見るボタン */}
        <button
          onClick={() => setScreen('complete')}
          className="mt-8 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-bold py-4 px-12 rounded-xl transition text-xl shadow-lg animate-pulse"
        >
          🏆 ランキングを見る
        </button>

        {/* 脱出アニメーション用CSS */}
        <style>{`
          @keyframes escapeRun {
            0% { transform: translateY(0) translateX(0); opacity: 1; }
            50% { transform: translateY(-20px) translateX(50px); opacity: 1; }
            100% { transform: translateY(-100px) translateX(200px); opacity: 0; }
          }
        `}</style>
      </div>
    );
  }

    // 完了画面
  if (screen === 'complete') {
    // 自分のランキング順位を取得
    const myRank = rankings.findIndex(t => t.code === teamNumber) + 1;

    return (
      <div className="fixed inset-0 bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 flex items-center justify-center p-4 overflow-auto" style={{zIndex: 9999}}>
        <div className="bg-gray-800 bg-opacity-95 p-8 rounded-2xl shadow-2xl max-w-2xl w-full border-2 border-cyan-500">
          {gameCompleted ? (
            <>
              <div className="text-center mb-6">
                <div className="text-6xl mb-4">🎉</div>
                <h1 className="text-4xl font-bold text-green-400 mb-2">脱出成功！</h1>
                <p className="text-cyan-300 text-lg">おめでとうございます！</p>
              </div>

              <div className="bg-gray-900 rounded-xl p-6 mb-6 text-center">
                <p className="text-gray-400 text-sm mb-1">チーム名</p>
                <p className="text-white text-2xl font-bold mb-3">{teamName}</p>

                <div className="flex justify-center items-center gap-8 mb-4">
                  <div>
                    <p className="text-gray-400 text-sm mb-1">クリアタイム</p>
                    <p className="text-3xl font-bold text-green-400 font-mono">
                      {formatTime(completionTime || 0)}
                    </p>
                  </div>
                  {myRank > 0 && (
                    <div>
                      <p className="text-gray-400 text-sm mb-1">順位</p>
                      <p className="text-3xl font-bold text-yellow-400">
                        {myRank === 1 ? '🥇' : myRank === 2 ? '🥈' : myRank === 3 ? '🥉' : ''} {myRank}位
                      </p>
                    </div>
                  )}
                </div>
              </div>

              {/* ランキング表示 */}
              {rankings.length > 0 && (
                <div className="mb-6">
                  <h2 className="text-xl font-bold text-cyan-400 mb-3 text-center">🏆 ランキング</h2>
                  <div className="bg-gray-900 rounded-lg border border-cyan-500 overflow-hidden max-h-60 overflow-y-auto">
                    <table className="w-full">
                      <thead className="bg-gray-700 sticky top-0">
                        <tr>
                          <th className="py-2 px-3 text-left text-gray-300 text-sm">順位</th>
                          <th className="py-2 px-3 text-left text-gray-300 text-sm">チーム名</th>
                          <th className="py-2 px-3 text-right text-gray-300 text-sm">タイム</th>
                        </tr>
                      </thead>
                      <tbody>
                        {rankings.map((team, idx) => (
                          <tr
                            key={team.code}
                            className={`${team.code === teamNumber ? 'bg-cyan-900 bg-opacity-50' : idx % 2 === 0 ? 'bg-gray-800' : 'bg-gray-850'}`}
                          >
                            <td className="py-2 px-3 text-white font-bold">
                              {idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : ''} {idx + 1}
                            </td>
                            <td className={`py-2 px-3 ${team.code === teamNumber ? 'text-cyan-300 font-bold' : 'text-white'}`}>
                              {team.name} {team.code === teamNumber && '(あなた)'}
                            </td>
                            <td className="py-2 px-3 text-right text-green-400 font-mono">
                              {formatTime(team.time)}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
            </>
          ) : (
            <>
              <div className="text-center">
                <div className="text-6xl mb-4">⏰</div>
                <h1 className="text-4xl font-bold text-red-400 mb-4">時間切れ</h1>
                <p className="text-cyan-300 text-xl mb-6">お疲れ様でした！</p>

                <div className="bg-gray-900 rounded-xl p-6 mb-6">
                  <p className="text-gray-400 text-sm mb-2">チーム名</p>
                  <p className="text-white text-2xl font-bold mb-4">{teamName}</p>

                  <div className="border-t border-gray-700 pt-4 mt-4">
                    <p className="text-gray-400 text-sm mb-2">収集したヒント</p>
                    <p className="text-2xl font-bold text-yellow-400">
                      {hintsFound.length} / {getTeamSettings(teamSize).hintsRequired}
                    </p>
                  </div>
                </div>

                <p className="text-gray-400 text-sm mb-6">
                  惜しい！もう少しで脱出できたかも...
                </p>
              </div>
            </>
          )}

        </div>
      </div>
    );
  }

  return null;
};


    ReactDOM.render(<CyberEscapeGame />, document.getElementById('root'));
  </script>
</body>
</html>
